{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "bf214d7f_782d1a90",
        "filename": "crypto/chacha/chacha_test.cc",
        "patchSetId": 5
      },
      "lineNbr": 363,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-28T22:54:54Z",
      "side": 1,
      "message": "This is somewhat moot because aarch64 (or, rather, Armv8-A) always has NEON, but ideally we\u0027d do a capability check here too.",
      "revId": "56f9af40d9d0653de4597ac2a518e201ffeefceb",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f425fce_03c49179",
        "filename": "crypto/chacha/chacha_test.cc",
        "patchSetId": 5
      },
      "lineNbr": 363,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-28T23:07:07Z",
      "side": 1,
      "message": "If we were implementing an OS kernel then we might not be able to use NEON even if it is available in the CPU; see `kernel_neon_begin()`/`kernel_neon_end()` in the Linux Kernel.\n\nHowever, do we need to consider that case here? Do we actually have test coverage of any only-if-NEON-isn\u0027t-available AArch64 assembly code paths?\n\nNow I\u0027m thinking I should just delete the non-NEON assembly implementation and implement the fallback logic so that it falls back to the C implementation if NEON isn\u0027t available. At least the C implementation is tested through the NO_ASM configuration. WDYT?",
      "parentUuid": "bf214d7f_782d1a90",
      "revId": "56f9af40d9d0653de4597ac2a518e201ffeefceb",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6a7ba33_e49bb3f9",
        "filename": "crypto/chacha/chacha_test.cc",
        "patchSetId": 5
      },
      "lineNbr": 363,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-12-01T21:41:43Z",
      "side": 1,
      "message": "For this CL I will try to keep things semantically the same as before. I added the capability check to the test.",
      "parentUuid": "1f425fce_03c49179",
      "revId": "56f9af40d9d0653de4597ac2a518e201ffeefceb",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31864daa_ccc17fe3",
        "filename": "crypto/chacha/internal.h",
        "patchSetId": 5
      },
      "lineNbr": 38,
      "author": {
        "id": 14196
      },
      "writtenOn": "2023-11-28T22:10:37Z",
      "side": 1,
      "message": "maybe just \"hw\" just like the followon cl?",
      "range": {
        "startLine": 38,
        "startChar": 20,
        "endLine": 38,
        "endChar": 24
      },
      "revId": "56f9af40d9d0653de4597ac2a518e201ffeefceb",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "240c1d19_796cabd4",
        "filename": "crypto/chacha/internal.h",
        "patchSetId": 5
      },
      "lineNbr": 38,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-30T04:28:08Z",
      "side": 1,
      "message": "I think it\u0027s best to use \"_hw\" to refer to something more specific than some kind of SIMD instructions, to be analogous to with SHA- CL and with existing AES implementations.\n\nNote that also on X86-64 there are many different SIMD implementations, and in the future there probably will be many SIMD implementations for Aarch64 too. So, I do not intend to come up with a generic \"_SIMD\" or whatever name since no two SIMD instruction sets have the same feature set.",
      "parentUuid": "31864daa_ccc17fe3",
      "range": {
        "startLine": 38,
        "startChar": 20,
        "endLine": 38,
        "endChar": 24
      },
      "revId": "56f9af40d9d0653de4597ac2a518e201ffeefceb",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}