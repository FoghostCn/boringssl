{
  "comments": [
    {
      "key": {
        "uuid": "562a227b_037dbcc4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 5525
      },
      "writtenOn": "2015-11-02T20:03:44Z",
      "side": 1,
      "message": "Normally, though, the certificate verifier isn\u0027t required to check the end-entity key for anything.\n\nIMO, whatever thing does the signature verification should verify that the key used for the signature verification is good enough.",
      "range": {
        "startLine": 17,
        "startChar": 12,
        "endLine": 18,
        "endChar": 20
      },
      "revId": "a05b6139f9e84ce6d16a924b0c82a2d0d3f1264c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9653ba54_18dc4507",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-11-03T22:22:01Z",
      "side": 1,
      "message": "\u003e Normally, though, the certificate verifier isn\u0027t required to check the end-entity key for anything.\n\nNot sure about \"Normally\". At least in OpenSSL/BoringSSL, the TLS stack certainly isn\u0027t enforcing anything. No minimum RSA key size or anything. Even this code wasn\u0027t doing anything because it fails to kick in for TLS 1.1. In Chromium, we\u0027ve always enforced such things in the verifier.\n\nAmusingly, OpenSSL 1.0.2 did have some off-by-default code to check the entire certificate chain against signature_algorithms (also as part of Suite B code), but it was a mess, so we\u0027ve ditched it. That I think that one we\u0027d both agree is the verifier\u0027s problem.\n\n\u003e IMO, whatever thing does the signature verification should verify that the key used for the signature verification is good enough\n\nThat did occur to me. I\u0027m not entirely opposed to doing it in the TLS stack, but I think it\u0027s simpler to put it all in the verifier. The verifier will have to enforce the exact same constraints on the rest of the chain, so we\u0027ll just be specifying everything twice. And we\u0027d need to figure out APIs in BoringSSL to specify all of that since OpenSSL/BoringSSL has not historically done any of this. (In fact, I\u0027d probably do it by hooking into a callback that sees the certificate... which is the certificate verifier.)",
      "parentUuid": "562a227b_037dbcc4",
      "range": {
        "startLine": 17,
        "startChar": 12,
        "endLine": 18,
        "endChar": 20
      },
      "revId": "a05b6139f9e84ce6d16a924b0c82a2d0d3f1264c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "96d65a0b_60f772b7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 5190
      },
      "writtenOn": "2015-11-03T23:14:10Z",
      "side": 1,
      "message": "It took me a while to parse this commit description. I\u0027m not sure BoringSSL convention, but I would actually push back against the sort of \u0027conversational\u0027 style of comments, which are less clear (e.g. \"But, either way.\")\n\nHere\u0027s an attempt at wording it, in part, to make sure I understood it.\n\n\n\nStop verifying that the curve sent in the peer\u0027s certificate matches those of the EC parameters sent to the peer.\n\nThis code has several bugs in the existing implementation, but also design concerns about whether it\u0027s correct to begin with:\n- This behaviour only happens for TLS 1.2, so a malicious peer could bypass this behaviour by only offering TLS 1.1.\n-  https://boringssl-review... incorrectly made this check go from a client-only check to a server-only check; both of which are wrong (either both parties should be checking or neither party should be checking).\n- On a design front, this is somewhat suspect, and already a point of interop issues among implementations.\n  - Option A: Validate that all of the certificates sent by the other party match our constraints. However, this doesn\u0027t work if the TLS library isn\u0027t also responsible for the PKI validation, since the peer could have just been sending conforming junk.\n  - Option B: Enforce these requirements during path validation, on the verified chain. However, if this leads to an error, it\u0027s not necessarily the fault of the peer - if these constraints weren\u0027t considered as part of path building, then there might be valid paths that meet these requirements that weren\u0027t considered.\n  - Option C: Do nothing, and leave it up to the caller (e.g. the one responsible for validating certificates) to make decisions about what it will accept; treat this merely as a hint for servers when selecting the set of certificate(s) to send.\n\nThis was originally introduced for Suite B mode in upstream OpenSSL, except there were several issues with that code and both that functionality - and the sheer number of non-Suite B curves - are no longer supported in BoringSSL.",
      "revId": "a05b6139f9e84ce6d16a924b0c82a2d0d3f1264c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    }
  ]
}