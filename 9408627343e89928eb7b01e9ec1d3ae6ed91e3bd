{
  "comments": [
    {
      "key": {
        "uuid": "285c0bf5_9ad76ef1",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 33,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-01-29T20:43:44Z",
      "side": 1,
      "message": "Skipped and rejected should be the same thing. The server logic is:\n\nif (client did not offer early data) {\n  early data not offered\n  (no post-ClientHello application records to worry about)\n} else if (server is happy accepting early data) {\n  accept early data\n  (decrypt the post-ClientHello application records)\n} else {\n  reject early data\n  (skip the post-ClientHello application records)\n}\n\nDid you observe a third state?",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa786b12_19ca34b0",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 33,
      "author": {
        "id": 5645
      },
      "writtenOn": "2020-01-30T01:49:12Z",
      "side": 1,
      "message": "The state that I am calling \"rejected\" occurs in the following cases:\n\nFAILED (SkipEarlyData-HRR-TLS13-Split)\nFAILED (EarlyData-HRR-Server-TLS13-Split)\nFAILED (EarlyData-HRR-RejectTicket-Server-TLS13-Split)\n\nSo I guess that is the answer?  Rejection of early data in the Hello Retry case is different from rejection of early data because the PSK was wrong?\n\nMaybe we don\u0027t care about the difference between these cases.  I could try to remove it in a prefactoring CL.  Thoughts?",
      "parentUuid": "285c0bf5_9ad76ef1",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c9e422a_189cb760",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 33,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-01-30T02:44:16Z",
      "side": 1,
      "message": "Ohhhh. Yes, you\u0027re right. So it\u0027s actually four states. Hrmf.\n\nWell, really it\u0027s three because early_data_not_offered and early_data_rejected (w/o skip) should be identical (I think?), but I guess that\u0027d change if someone ever asks for an SSL_get_early_data_offered API or something?\n\nMaybe early_data_rejected_hrr? Or early_data_already_skipped? I dunno. :-)",
      "parentUuid": "aa786b12_19ca34b0",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "415c152c_693ab491",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 33,
      "author": {
        "id": 5645
      },
      "writtenOn": "2020-02-03T22:32:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3c9e422a_189cb760",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "23b24d54_a8739144",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 349,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-01-29T20:43:44Z",
      "side": 1,
      "message": "Ah, my bad. When I suggested the tristate enum, I hadn\u0027t realized that handback_tls13 and handback_tls13_early_data would be separate states. There\u0027s another invariant here which is that type \u003d\u003d handback_tls13_early_data if and only if early_data \u003d\u003d early_data_accepted.\n\nIn that case, I wonder if we should have:\n\n  type \u003d\u003d handback_tls13 \u003d\u003e {\n      get a skip_early_data boolean;\n      early_data_offered \u003d skip_early_data;\n      early_data_accepted \u003d false;\n  }\n  type \u003d\u003d handshake_tls13_early_data \u003d\u003e {\n      no extra boolean\n      skip_early_data \u003d false;\n      early_data_offered \u003d true;\n      early_data_accepted \u003d true;\n  }\n\nThoughts? (I figure the more invariants that are burned into the serialization, the less hard we have to think about the peer sending garbage inputs.)",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09044e5b_4dbac025",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 349,
      "author": {
        "id": 5645
      },
      "writtenOn": "2020-01-30T01:49:12Z",
      "side": 1,
      "message": "For now, I\u0027ve added a check that the state matches the enum value.  I\u0027ll carry your suggestion farther once we resolve the rejected vs. skipped question.",
      "parentUuid": "23b24d54_a8739144",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe63918f_43fbddef",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 349,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-02-03T20:05:44Z",
      "side": 1,
      "message": "SGTM",
      "parentUuid": "09044e5b_4dbac025",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4e96e31_8d09c32f",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 349,
      "author": {
        "id": 5645
      },
      "writtenOn": "2020-02-03T22:32:10Z",
      "side": 1,
      "message": "(Nothing else to change here, I think, since we\u0027re keeping the four-valued enum.)",
      "parentUuid": "fe63918f_43fbddef",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "176b61ab_e1f6cf08",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 655,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-01-29T20:43:44Z",
      "side": 1,
      "message": "Spans are the best...",
      "range": {
        "startLine": 655,
        "startChar": 9,
        "endLine": 655,
        "endChar": 17
      },
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ad54f55_efc44aaa",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 667,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-01-29T20:43:44Z",
      "side": 1,
      "message": "Hrm. I was going to suggest that the annoying digest_len checks in 605-631 could be CBS_copy_bytes (forgot that function!), but it looks like CBS_copy_bytes is really CBS_consume_N_bytes and, if write_seq is too big, it\u0027ll silently truncate.\n\nA thought: what if you added a little helper function (not attached to name, feel free to change)\n\nstatic bool CopyExact(Span\u003cuint8_t\u003e out, const CBS *in) {\n  if (CBS_len(in) !\u003d out.size()) {\n    return false;\n  }\n  OPENSSL_memcpy(out.data(), CBS_data(in), out.size());\n  return true;\n}\n\nAnd then replaced both of these plus all the secret copies with that. The secrets would then just be:\n\n    const size_t digest_len \u003d hs-\u003etranscript.DigestLen();\n    hs-\u003eResizeSecrets(digest_len);\n    if (!CopyExact(hs-\u003eclient_traffic_secret_0(),\n                   \u0026client_traffic_secret_0) ||\n        !CopyExact(hs-\u003eserver_traffic_secret_0(),\n                   \u0026server_traffic_secret_0) ||\n        // ...\n\nwhich seems much tidier.",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6200efb9_db9165e4",
        "filename": "ssl/handoff.cc",
        "patchSetId": 3
      },
      "lineNbr": 667,
      "author": {
        "id": 5645
      },
      "writtenOn": "2020-01-30T01:49:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0ad54f55_efc44aaa",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "93d761c7_d2ee5809",
        "filename": "ssl/handshake.cc",
        "patchSetId": 3
      },
      "lineNbr": 626,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-01-29T20:43:44Z",
      "side": 1,
      "message": "Note this does put it in two separate writes, which is hopefully fine? Right now we manage to pack it all into a single write, which packetizes better. But I suppose the caller can always do that.\n\nAnother option would be if the handoff code serialized the outgoing buffer (does it?). But I think it\u0027s fine as is. Just pointing this out as an observation.",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90fb7ac1_fa6fd920",
        "filename": "ssl/handshake.cc",
        "patchSetId": 3
      },
      "lineNbr": 626,
      "author": {
        "id": 5645
      },
      "writtenOn": "2020-01-30T01:49:12Z",
      "side": 1,
      "message": "Yes.  My thinking was that at most there is a little more SSL record overhead, and that (as you say) the caller can ensure that the records go on the wire as a single packet.  Does that sound right?",
      "parentUuid": "93d761c7_d2ee5809",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d949f2e_c5746db2",
        "filename": "ssl/handshake.cc",
        "patchSetId": 3
      },
      "lineNbr": 626,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-02-03T20:05:44Z",
      "side": 1,
      "message": "I don\u0027t think there\u0027s even SSL record overhead. Just the packet stuff.",
      "parentUuid": "90fb7ac1_fa6fd920",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dded1259_0d7ef0ca",
        "filename": "ssl/tls13_server.cc",
        "patchSetId": 3
      },
      "lineNbr": 720,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-01-29T20:43:44Z",
      "side": 1,
      "message": "May as well move inside the existing conditional.",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5fd17cf_238e1f39",
        "filename": "ssl/tls13_server.cc",
        "patchSetId": 3
      },
      "lineNbr": 720,
      "author": {
        "id": 5645
      },
      "writtenOn": "2020-01-30T01:49:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dded1259_0d7ef0ca",
      "revId": "9408627343e89928eb7b01e9ec1d3ae6ed91e3bd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    }
  ]
}