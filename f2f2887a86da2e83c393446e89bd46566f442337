{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f2956b57_4c56c3a8",
        "filename": "util/fipstools/delocate/delocate.go",
        "patchSetId": 1
      },
      "lineNbr": 1406,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-08-21T17:32:18Z",
      "side": 1,
      "message": "Do we have automated test coverage for PAC/BTI configurations internally? I suspect these functions will need a BTI marker if we (or the compiler) ever indirects one of them through a function pointer.\n\nDoesn\u0027t have to be for this CL, but since it sounds like you\u0027re interested in PAC/BTI, I wanted to make sure we\u0027re thinking about this.\n\n(I don\u0027t know off-hand if we currently do. We may be getting lucky right now. But at least for asm, our story so far has been to conservatively tag every function as a BTI entrypoint because we can\u0027t stop the compiler from deciding to indirect a call.)",
      "revId": "f2f2887a86da2e83c393446e89bd46566f442337",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "349caf29_8e03041f",
        "filename": "util/fipstools/delocate/delocate.go",
        "patchSetId": 1
      },
      "lineNbr": 1406,
      "author": {
        "id": 16846
      },
      "writtenOn": "2023-08-21T17:53:29Z",
      "side": 1,
      "message": "We do not. But we might be able to in the near future. This patch makes the whole thing build first, a prerequisite of testing :D\n\nFrom what reading the code though, a large part seems PAC/BTI aware -- openssl/asm_base.h defines a few macros for that (`AARCH64_SIGN_LINK_REGISTER`, `AARCH64_VALIDATE_LINK_REGISTER`, and `AARCH64_VALID_CALL_TARGET`) and they are used in the assembly files. Compiler-generated assemblies are taken care of by the compiler.",
      "parentUuid": "f2956b57_4c56c3a8",
      "revId": "f2f2887a86da2e83c393446e89bd46566f442337",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d19cd871_09296f70",
        "filename": "util/fipstools/delocate/delocate.go",
        "patchSetId": 1
      },
      "lineNbr": 1406,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-08-21T18:06:06Z",
      "side": 1,
      "message": "The compiler-generated assembly is, yeah, the compiler\u0027s problem. Our assembly *should* be fine, though it sure would be nice to have a way to test it. But there\u0027s also delocate-generated assembly. For various horrible reasons, any time BCM references a function outside of BCM it goes through a redirector function.\n\nIf that reference is an indirect call, I think we\u0027d need a BTI marker in the redirector.\n\nUnfortunately, I don\u0027t think delocate can use the `AARCH64_VALID_CALL_TARGET` macros because the preprocessor has already run, but `hint` is just a nop, right? Perhaps the thing to do is update `writeAarch64Function` as:\n\n```\nfunc writeAarch64Function(w stringWriter, funcName string, writeContents func(stringWriter)) {\n\tw.WriteString(\".p2align 2\\n\")\n\tw.WriteString(\".hidden \" + funcName + \"\\n\")\n\tw.WriteString(\".type \" + funcName + \", @function\\n\")\n\tw.WriteString(funcName + \":\\n\")\n\tw.WriteString(\".cfi_startproc\\n\")\n\tw.WriteString(\"\\thint #34\\n\")  // bti c\n\twriteContents(w)\n\tw.WriteString(\".cfi_endproc\\n\")\n\tw.WriteString(\".size \" + funcName + \", .-\" + funcName + \"\\n\")\n}\n```\n\nOr if we want to save an instruction in the non-BTI configurations:\n\n```\nfunc writeAarch64Function(w stringWriter, funcName string, writeContents func(stringWriter)) {\n\tw.WriteString(\".p2align 2\\n\")\n\tw.WriteString(\".hidden \" + funcName + \"\\n\")\n\tw.WriteString(\".type \" + funcName + \", @function\\n\")\n\tw.WriteString(funcName + \":\\n\")\n\tw.WriteString(\".cfi_startproc\\n\")\n\tw.WriteString(\"#if defined(__ARM_FEATURE_BTI_DEFAULT) \u0026\u0026 __ARM_FEATURE_BTI_DEFAULT \u003d\u003d 1\\n\")\n\tw.WriteString(\"\\thint #34\\n\")  // bti c\n\tw.WriteString(\"#endif\\n\")\n\twriteContents(w)\n\tw.WriteString(\".cfi_endproc\\n\")\n\tw.WriteString(\".size \" + funcName + \", .-\" + funcName + \"\\n\")\n}\n```",
      "parentUuid": "349caf29_8e03041f",
      "revId": "f2f2887a86da2e83c393446e89bd46566f442337",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "565c43c7_885ce37e",
        "filename": "util/fipstools/delocate/delocate.go",
        "patchSetId": 1
      },
      "lineNbr": 1406,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-08-21T18:07:41Z",
      "side": 1,
      "message": "(Although I don\u0027t know off-hand if the preprocessor works on delocate output right now. It might generate a `.s` file instead of a `.S` file...)",
      "parentUuid": "d19cd871_09296f70",
      "revId": "f2f2887a86da2e83c393446e89bd46566f442337",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f22420c_f06352a4",
        "filename": "util/fipstools/delocate/delocate.go",
        "patchSetId": 1
      },
      "lineNbr": 1406,
      "author": {
        "id": 16846
      },
      "writtenOn": "2023-08-22T00:12:42Z",
      "side": 1,
      "message": "The CMake -\u003e Ninja build process actually generates a `.S` file, but internally we name the file with `.s`.\n\nI use the `AARCH64_VALID_CALL_TARGET` macro along with `#include \u003copenssl/asm_base.h\u003e`. It works internally once I changed the file suffix to `.S` (and add the header as a dependency to it). See the last file in cl/557871388 for the required change.",
      "parentUuid": "565c43c7_885ce37e",
      "revId": "f2f2887a86da2e83c393446e89bd46566f442337",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f8c98bb_f2c21b41",
        "filename": "util/fipstools/delocate/delocate.go",
        "patchSetId": 1
      },
      "lineNbr": 1406,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-08-22T17:10:24Z",
      "side": 1,
      "message": "Ah cool. So we don\u0027t forget, mind adding to the CL description:\n\n```\nUpdate-Note: The output of delocate now needs to end in .S instead of .s to run\nthrough the preprocessor. See cl/557871388.\n```\n\n(Just a note to our future selves so we don\u0027t forget.)\n\nUsing `#include \u003copenssl/asm_base.h\u003e` is a little interesting because including it adds a bunch of marker sections as side effects. Then again, delocate is already combining lots of asm files together so evidently we\u0027re okay with the duplicates of those marker sections anyway.",
      "parentUuid": "3f22420c_f06352a4",
      "revId": "f2f2887a86da2e83c393446e89bd46566f442337",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d64fe73e_4de1921f",
        "filename": "util/fipstools/delocate/delocate.go",
        "patchSetId": 1
      },
      "lineNbr": 1406,
      "author": {
        "id": 16846
      },
      "writtenOn": "2023-08-30T00:33:41Z",
      "side": 1,
      "message": "Added the Update-Note.\n\nThe include only add one section. The rest comes from the input assembly, which all include the same header so each gets a copy. The note sections only contain the `GNU_PROPERTY_AARCH64_FEATURE_1_AND` property, which are all ended together at the final linking, so duplicates are not a big problem.",
      "parentUuid": "3f8c98bb_f2c21b41",
      "revId": "f2f2887a86da2e83c393446e89bd46566f442337",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}