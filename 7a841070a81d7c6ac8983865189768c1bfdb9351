{
  "comments": [
    {
      "key": {
        "uuid": "3d867566_e249e9eb",
        "filename": "include/openssl/pem.h",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 5070
      },
      "writtenOn": "2018-09-25T23:29:25Z",
      "side": 1,
      "message": "Can you elaborate in the description what the rule is then? We\u0027re allowed to cast function pointers into void*/** as long we end up calling them via a pointer that has their true type? If so, what was this code doing before? (Calling them with a pointer argument turned into a void *?)",
      "range": {
        "startLine": 129,
        "startChar": 7,
        "endLine": 129,
        "endChar": 72
      },
      "revId": "7a841070a81d7c6ac8983865189768c1bfdb9351",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5fe82652_6c5b950b",
        "filename": "include/openssl/pem.h",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-09-25T23:47:04Z",
      "side": 1,
      "message": "Disclaimer: I could be completely wrong here...\n\nThis comment is about something else.\n\nThat\u0027s just about take our void **x and using it as a type **. IIRC, you can cast data pointers around (modulo some dumb rules around alignment), but if you actually dereference that pointer under the wrong type, then strict aliasing rules kick in. I believe strict aliasing does not allow this:\n\n  int *x;\n  int **y \u003d \u0026x;\n  void **z \u003d (void **)y;  // Allowed; types have compatible\n                          // alignment and we\u0027re not actually\n                          // dereferencing stuff yet.\n  int w;\n  *y \u003d \u0026w;  // Allowed; y points to an int* and is being\n            // dereferenced as an int*.\n  *z \u003d \u0026w;  // Not allowed. z actually points to an int*\n            // but is being dereferenced as a void*.\n\nThus casting to and from void** and T** is dubious but not immediately problematic. In this case, it\u0027s fine because we are ultimately dereferencing it as a type **. The comment was meant to explain why it was fine.\n\nAlthough... actually, as I write this, it occurs to me that the ASN1_ITEM nonsense violates this rule everywhere and d2i_Foo is typically an ASN1_ITEM thing. (But not always since they can also just be our own reimplementations.) So maybe I should just delete the comment because it\u0027s sort of silly anyway. :-)\n\nSeparately, the rule for function pointers that\u0027s upsetting CFI is that you can cast them to other function types if you like for storage, but you must cast the, back to the exact same type before you call them.\n\nWhether you can cast function pointers to void* is a mess. MSVC will scream at you. I think GCC throws a warning. C doesn\u0027t promise you can because of architectures where code and data pointers are different size. I forget if it is undefined or impl-defined or what. Either way, we weren\u0027t doing it before or after this change. MSVC would have screamed.\n\n\nBasically, C is terrible. :-)",
      "parentUuid": "3d867566_e249e9eb",
      "range": {
        "startLine": 129,
        "startChar": 7,
        "endLine": 129,
        "endChar": 72
      },
      "revId": "7a841070a81d7c6ac8983865189768c1bfdb9351",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96a735dd_65863f35",
        "filename": "include/openssl/pem.h",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-09-25T23:55:21Z",
      "side": 1,
      "message": "int *x;\n  int **y \u003d \u0026x;\n  void **z \u003d (void **)y;  // Allowed; types have compatible\n                          // alignment and we\u0027re not actually\n                          // dereferencing stuff yet\n\nHuh. I wonder if this is not actually always okay...\n\n\nA pointer to void shall have the same representation and alignment requirements as a\npointer to a character type. Similarly, pointers to qualified or unqualified versions of\ncompatible types shall have the same representation and alignment requirements. All\npointers to structure types shall have the same representation and alignment requirements\nas each other. All pointers to union types shall have the same representation and\nalignment requirements as each other. Pointers to other types need not have the same\nrepresentation or alignment requirements.\n\n\nAnd then later on:\n\n\nA pointer to an object type may be converted to a pointer to a different object type. If the\nresulting pointer is not correctly aligned for the referenced type, the behavior is\nundefined. Otherwise, when converted back again, the result shall compare equal to the\noriginal pointer. When a pointer to an object is converted to a pointer to a character type,\nthe result points to the lowest addressed byte of the object. Successive increments of the\nresult, up to the size of the object, yield pointers to the remaining bytes of the object\n\n\nThe referenced types in this conversion are int* and void*, but the first but doesn\u0027t promise that int* and void* have the same alignment requirements.\n\nBut the particular alignment of each type is implementation-defined, and they have the same alignment between int* and void*, so we know we don\u0027t hit that undefined case.\n\n\nBLEGH.",
      "parentUuid": "5fe82652_6c5b950b",
      "range": {
        "startLine": 129,
        "startChar": 7,
        "endLine": 129,
        "endChar": 72
      },
      "revId": "7a841070a81d7c6ac8983865189768c1bfdb9351",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba8dd5ab_af9061bc",
        "filename": "include/openssl/pem.h",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-09-26T23:17:39Z",
      "side": 1,
      "message": "One battle at a time.\n\nI would drop this comment but mention in the change description that the aim is to ensure that when calling a function through a function-pointer, the type of the pointer must exactly match the true type of the function.",
      "parentUuid": "96a735dd_65863f35",
      "range": {
        "startLine": 129,
        "startChar": 7,
        "endLine": 129,
        "endChar": 72
      },
      "revId": "7a841070a81d7c6ac8983865189768c1bfdb9351",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    }
  ]
}