{
  "comments": [
    {
      "key": {
        "uuid": "f10fad76_571fbcf6",
        "filename": "crypto/bn/montgomery.c",
        "patchSetId": 1
      },
      "lineNbr": 382,
      "author": {
        "id": 5525
      },
      "writtenOn": "2016-03-28T22:19:11Z",
      "side": 1,
      "message": "(signed value) - (unsigned value) -\u003e signed value.\n\nThen we assign that to an variable with an unsigned type.\n\nThat\u0027s confusing as we have unsigned-\u003esigned-\u003eunsigned for no reason. It\u0027s better to reduce the number of signed/unsigned conversions.\n\nI would write `intptr_t m \u003d (intptr_t)0 - (intptr_t)v;` because then there\u0027s only one conversion from unsigned to signed.\n\nAnyway, I\u0027m pretty sure that this was the train of thought of the person who did the unfinished reformatting.\n\nIt might also be useful to `assert(v \u003d\u003d 0 || v \u003d\u003d 1);` and `assert(carry \u003d\u003d 0 || carry \u003d\u003d 1)`;",
      "range": {
        "startLine": 382,
        "startChar": 4,
        "endLine": 382,
        "endChar": 26
      },
      "revId": "bbd99f57052794e2cfae99940d5587b33215ef14",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "51c95978_d9c7575f",
        "filename": "crypto/bn/montgomery.c",
        "patchSetId": 1
      },
      "lineNbr": 382,
      "author": {
        "id": 5415
      },
      "writtenOn": "2016-03-28T22:24:51Z",
      "side": 1,
      "message": "I\u0027m not sure I follow. I suppose 0 should be 0u, I can fix that. But m was an unsigned value in the original code too (size_t). The rest of the computation is unsigned everywhere. Note that the LHS of this diff is *not* the original code. The original code uses PTR_SIZE_INT which is size_t.\n\nAlthough, now that I look at this again, I see it\u0027s trying to pick one of two pointers in constant time?? That seems kind of ridiculous. The memory access pattern won\u0027t be constant anyway.\n\n(Hilariously, OpenSSL uses size_t for PTR_SIZE_INT as well, except on VMS, where it\u0027s either a *signed* int or long long!)",
      "parentUuid": "f10fad76_571fbcf6",
      "range": {
        "startLine": 382,
        "startChar": 4,
        "endLine": 382,
        "endChar": 26
      },
      "revId": "bbd99f57052794e2cfae99940d5587b33215ef14",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f10fad76_f7c34872",
        "filename": "crypto/bn/montgomery.c",
        "patchSetId": 1
      },
      "lineNbr": 382,
      "author": {
        "id": 5525
      },
      "writtenOn": "2016-03-28T22:33:57Z",
      "side": 1,
      "message": "I think s/0/0u/ or maybe s/0/(uintptr_t)0/ also makes sense. Then we\u0027ve eliminated the signed/unsigned conversions completely.\n\nYes, this is trying to do a constant-time select between the two pointers in a bad way. I believe some of the assembly language implementations may also be doing this. It should eventually be fixed. That is far from the worst problem with this code, unfortunately. Solving the worse problems will eventually make this problem go away, I think.",
      "parentUuid": "51c95978_d9c7575f",
      "range": {
        "startLine": 382,
        "startChar": 4,
        "endLine": 382,
        "endChar": 26
      },
      "revId": "bbd99f57052794e2cfae99940d5587b33215ef14",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "51c95978_39e68bfe",
        "filename": "crypto/bn/montgomery.c",
        "patchSetId": 1
      },
      "lineNbr": 399,
      "author": {
        "id": 5415
      },
      "writtenOn": "2016-03-28T22:28:02Z",
      "side": 1,
      "message": "...dammit, is someone trying to optimize the instruction scheduling in *C*???",
      "revId": "bbd99f57052794e2cfae99940d5587b33215ef14",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f10fad76_f79a289a",
        "filename": "crypto/bn/montgomery.c",
        "patchSetId": 1
      },
      "lineNbr": 399,
      "author": {
        "id": 5525
      },
      "writtenOn": "2016-03-28T22:38:13Z",
      "side": 1,
      "message": "I believe the process goes like this:\n1. The code is first written in a straightforward way.\n2. The code is rewritten to approximate the shape of the assembly language version.\n3. The assembly language version is written.\n4. In some cases, the C code is kept in sync with the assembly language so that the C code serves to document the assembly language code.\n\nYou can see this pattern often, especially in crypto/modes. This is helpful if you want to understand the assembly language code (though the C code is not kept 100% in sync with the assembly), but it is unhelpful for somebody who just wants to read C code.",
      "parentUuid": "51c95978_39e68bfe",
      "revId": "bbd99f57052794e2cfae99940d5587b33215ef14",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    }
  ]
}