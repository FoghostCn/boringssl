{
  "comments": [
    {
      "key": {
        "uuid": "b0242aae_78df7a55",
        "filename": "crypto/internal.h",
        "patchSetId": 3
      },
      "lineNbr": 411,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-04-14T17:49:08Z",
      "side": 1,
      "message": "clear -\u003e cleanup to be consistent with other init/cleanup pairs.",
      "range": {
        "startLine": 411,
        "startChar": 20,
        "endLine": 411,
        "endChar": 21
      },
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_31eb4cf4",
        "filename": "crypto/internal.h",
        "patchSetId": 3
      },
      "lineNbr": 411,
      "author": {
        "id": 5005
      },
      "writtenOn": "2015-04-14T20:03:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b0242aae_78df7a55",
      "range": {
        "startLine": 411,
        "startChar": 20,
        "endLine": 411,
        "endChar": 21
      },
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_04525a38",
        "filename": "crypto/thread_win.c",
        "patchSetId": 3
      },
      "lineNbr": 88,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-04-14T00:05:08Z",
      "side": 1,
      "message": "For this particular instance, you could also do:\n\n  void (*init_func)(void) \u003d *((void (*)(void))arg);\n\nand\n\n  run_once(in_once, call_once_init, \u0026init);",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_69768a85",
        "filename": "crypto/thread_win.c",
        "patchSetId": 3
      },
      "lineNbr": 88,
      "author": {
        "id": 5005
      },
      "writtenOn": "2015-04-14T20:03:16Z",
      "side": 1,
      "message": "The memcpy is verbose but clear I think.",
      "parentUuid": "b0242aae_04525a38",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_6400fe04",
        "filename": "crypto/thread_win.c",
        "patchSetId": 3
      },
      "lineNbr": 99,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-04-14T00:05:08Z",
      "side": 1,
      "message": "Probably worth documenting in crypto/internal.h that, on Windows, this is a mutex. Though I can\u0027t imagine how you might write code that cares, aside from performance.\n\nNit: /* comment style */",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_a98112d4",
        "filename": "crypto/thread_win.c",
        "patchSetId": 3
      },
      "lineNbr": 99,
      "author": {
        "id": 5005
      },
      "writtenOn": "2015-04-14T20:03:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b0242aae_6400fe04",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_a41dc667",
        "filename": "crypto/thread_win.c",
        "patchSetId": 3
      },
      "lineNbr": 123,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-04-14T00:05:08Z",
      "side": 1,
      "message": "Nit: ditto on comment style",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_49906e19",
        "filename": "crypto/thread_win.c",
        "patchSetId": 3
      },
      "lineNbr": 123,
      "author": {
        "id": 5005
      },
      "writtenOn": "2015-04-14T20:03:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b0242aae_a41dc667",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_a15378f0",
        "filename": "include/openssl/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-04-14T00:05:08Z",
      "side": 1,
      "message": "Is the idea that we\u0027ll put this into SSL_CTX? (And that we probably won\u0027t be able to opaquify it anytime soon if ever.) Since otherwise I don\u0027t see a real need to put them in public header files.\n\nSSL_CTX is the only case I can think of where we might want to embed a lock in a struct but will have a hard time making it opaque. Maybe we should just pay a malloc indirection on that one until we can opaquify it ourselves[*]? See comment below about an issue with this one.\n\n[*] I\u0027m cautiously optimistic that we\u0027ll be able to someday. Since OpenSSL 1.1.x is doing it, once the APIs are available, patches to third-party software to avoid accessing the structs directly should be quite upstreamable.",
      "range": {
        "startLine": 68,
        "startChar": 18,
        "endLine": 68,
        "endChar": 51
      },
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_9dc9f8fc",
        "filename": "include/openssl/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-04-14T17:32:11Z",
      "side": 1,
      "message": "Oh, I see. We\u0027ll want to put it on the RSA too, and maybe some other bits.\n\nMaybe we should drop in a C++11 file for now or try to assert on offsetof for alignment.",
      "parentUuid": "b0242aae_a15378f0",
      "range": {
        "startLine": 68,
        "startChar": 18,
        "endLine": 68,
        "endChar": 51
      },
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_c9f0de63",
        "filename": "include/openssl/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 5005
      },
      "writtenOn": "2015-04-14T20:03:16Z",
      "side": 1,
      "message": "Thanks for the point about the alignment. I\u0027ll use the union{} trick, which should handle that.",
      "parentUuid": "b0242aae_9dc9f8fc",
      "range": {
        "startLine": 68,
        "startChar": 18,
        "endLine": 68,
        "endChar": 51
      },
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_c1f0c463",
        "filename": "include/openssl/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 72,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-04-14T00:05:08Z",
      "side": 1,
      "message": "This doesn\u0027t account for any alignment requirements we may have.\n\nI think we\u0027d need to rope in C++11 to be able to statically assert on alignment. C11 also has _Alignof, but we probably don\u0027t get that on MSVC. Maybe we can do something crazy like assert on the offsetof the mutex in:\n\n  struct {\n    char byte;\n    CRYPTO_mutex_t mutex;\n  }",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_4904eecf",
        "filename": "include/openssl/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 72,
      "author": {
        "id": 5005
      },
      "writtenOn": "2015-04-14T20:03:16Z",
      "side": 1,
      "message": "(Done with a union.)",
      "parentUuid": "b0242aae_c1f0c463",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_f805aa41",
        "filename": "include/openssl/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-04-14T17:49:08Z",
      "side": 1,
      "message": "CRYPTO_mutex_t -\u003e CRYPTO_MUTEX? To be honest, I\u0027ve never been very fond of the SHOUTING_CASE type names, though it does match the rest of the code.",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0242aae_09302692",
        "filename": "include/openssl/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 5005
      },
      "writtenOn": "2015-04-14T20:03:16Z",
      "side": 1,
      "message": "Hmm, I think you\u0027re right that CRYPTO_MUTEX does fit better. Done. (And also CRYPTO_STATIC_MUTEX.)",
      "parentUuid": "b0242aae_f805aa41",
      "revId": "e22e9814d9a4eb1a0b0c17e59db6ed7c1a3f983f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    }
  ]
}