{
  "comments": [
    {
      "key": {
        "uuid": "56390f00_4f76f9b2",
        "filename": "ssl/s3_pkt.c",
        "patchSetId": 3
      },
      "lineNbr": 602,
      "author": {
        "id": 5075
      },
      "writtenOn": "2014-08-06T03:47:35Z",
      "side": 1,
      "message": "do_ssl3_write can\u0027t re-entrantly call ssl3_write, can it? Nothing outside this function reads it and, so, apart from that possibility, this should be equivalent to setting it at line 629. Which in turn should be equivalent to pulling it out of s-\u003es3 and into a local variable, initialized at 0, right?",
      "revId": "5ea669b7e0be21dcf6b4180f683ee21cb81589b7",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "56390f00_cf896967",
        "filename": "ssl/s3_pkt.c",
        "patchSetId": 3
      },
      "lineNbr": 654,
      "author": {
        "id": 5075
      },
      "writtenOn": "2014-08-06T03:47:35Z",
      "side": 1,
      "message": "Hrm. I don\u0027t think this is new with the change, and I still don\u0027t completely understand this code. But say we ssl3_write(1k), assemble a fragmented record, and don\u0027t manage to write it all. Maybe we write all but the final byte, so almost all of the previous IV has since hit the wire.\n\nThen the next iteration, we get ssl3_write(2k) with the first 1k the same data as before and then another 1k of additional data. We hit line 598, set fragment \u003d 1, and then go to do_ssl3_write. There\u0027s still a pending SSL3_BUFFER, so we ssl3_write_pending. And say that succeeds this time. So we return wb-\u003ewpend_ret and move on.\n\nssl3_write now thinks that the IV randomization is done and leaves record_split_done \u003d 1. The next record then gets written out without IV randomization.\n\nI thiiink checking wb-\u003eleft in line 596 would do the trick? Or perhaps if you set record_split_done \u003d 0 if i !\u003d n? Although that\u0027s is kinda ugly. I wonder if the fragmenting should be somewhere else. \n\n(Actually, is there any reason to maintain record_split_done at all? As opposed to always fragmenting every \u003e 1 byte application record.)",
      "revId": "5ea669b7e0be21dcf6b4180f683ee21cb81589b7",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "56390f00_da4f65a1",
        "filename": "ssl/s3_pkt.c",
        "patchSetId": 3
      },
      "lineNbr": 654,
      "author": {
        "id": 5075
      },
      "writtenOn": "2014-08-06T16:58:16Z",
      "side": 1,
      "message": "\u003e (Actually, is there any reason to maintain record_split_done at all? As opposed to always fragmenting every \u003e 1 byte application record.)\n\nAlright, now that I\u0027m more awake, I suppose you only want to fragment every time you get a new chunk of data you haven\u0027t committed to previously. So if we\u0027re writing out one buffer in a single call, that only needs one fragmenting. (Actually, that\u0027s a pretty good argument for why record_split_done should be a local variable.)\n\nPerhaps the ssl3_write_pending check could be moved to ssl3_write. Though do_ssl3_write is called in ssl3_dispatch_alert too, so do_ssl3_write would still need a check, or ssl3_dispatch_alert gets a copy too (maybe that\u0027s what we want). And if ssl3_dispatch_alert calls ssl3_write instead of ssl3_do_write, then ssl3_write can be re-entrantly called, making the local variable comment above more complicated...",
      "parentUuid": "56390f00_cf896967",
      "revId": "5ea669b7e0be21dcf6b4180f683ee21cb81589b7",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "56390f00_14ac040f",
        "filename": "ssl/test/bssl_shim.cc",
        "patchSetId": 3
      },
      "lineNbr": 186,
      "author": {
        "id": 5075
      },
      "writtenOn": "2014-08-06T03:47:35Z",
      "side": 1,
      "message": "Right, I keep forgetting this file is C++. (Say, would you object to my RAII-ing everything to avoid all this \u0027goto err\u0027 stuff? Also had been thinking we could do with a config struct that gets parsed once, in case the config wants to influence the SSL_CTX.)",
      "range": {
        "startLine": 186,
        "startChar": 2,
        "endLine": 186,
        "endChar": 6
      },
      "revId": "5ea669b7e0be21dcf6b4180f683ee21cb81589b7",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    }
  ]
}