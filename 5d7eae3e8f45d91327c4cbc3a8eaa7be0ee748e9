{
  "comments": [
    {
      "key": {
        "uuid": "6adebec2_bfd60704",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-09-29T22:50:20Z",
      "side": 1,
      "message": "This change seems to implicitly suggest that installing BoringSSL as a system library is a reasonable thing to do, but that would displace OpenSSL, and we explicitly do not try to be a drop-in OpenSSL replacement at the distro level.\n\nAlso, the CMake build is our development build. It\u0027s not really designed for anything else. Consumer projects use the source lists and configs from util/generate_build_files.py.",
      "revId": "5d7eae3e8f45d91327c4cbc3a8eaa7be0ee748e9",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "82184297_ceb9abc8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8844
      },
      "writtenOn": "2020-09-29T22:54:31Z",
      "side": 1,
      "message": "There are situations where I depend on projects that depend on BoringSSL (in this case I am playing with LSQUIC). I do believe that when the big crypto libraries (BoringSSL, LibreSSL, OpenSSL) all work with a project, then it is nice, with CMake, to be able to interchangeably use the one found by `find_package(OPENSSL REQUIRED)`.\n\nBecause BoringSSL is usually not installed on the system, I end up with a superbuild scheme, where I install the libraries into, say, `third_party/install`, and then I point `-DCMAKE_PREFIX_PATH` there. I know that many people use git submodules for dependencies, but I don\u0027t like that, and I think my use-case is valid.\n\nSo the question here is: is there a reason for not having a CMake install target for BoringSSL? :-)",
      "revId": "5d7eae3e8f45d91327c4cbc3a8eaa7be0ee748e9",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2850bc03_5c59c95d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8844
      },
      "writtenOn": "2020-09-30T07:42:15Z",
      "side": 1,
      "message": "Those are interesting points, thank you!\n\nI was not aware that the CMake build was considered \"development only\". I\u0027ve seen multiple projects (gRPC, LSQUIC) depending on it, maybe that\u0027s also for their development build, but the reality is that if I depend on gRPC and I need to build it for my platform, from sources, chances are that I will be using CMake, right? I am not completely convinced by the idea of forcing people who use CMake to patch BoringSSL just because otherwise it may suggest something that does not want to be suggested. For one, not having an install target almost never means - on the Internet - anything other than \"we don\u0027t use it this way and haven\u0027t felt it was necessary until now\". That\u0027s how I took it with BoringSSL; I knew about it being a replacement for distro OpenSSL thanks to the README.\n\nJust to elaborate on my use-case: I use the install target not to install system-wide, but to install it locally in a consistent way. It is very easy to \"install\" and then \"find_package(OPENSSL REQUIRED)\" with a modified CMAKE_PREFIX_PATH, and that seems fairly elegant to me (as compared to writing custom \"find_*\" stuff in CMakeLists or having BoringSSL as a git submodule). To me, the way it is in BoringSSL suggests that it should be used as a git submodule (and gRPC reinforces that feeling).\n\nAnyway, I can continue patching it myself on my side, it was just not clear to me why BoringSSL did not support that :-).",
      "parentUuid": "6adebec2_bfd60704",
      "revId": "5d7eae3e8f45d91327c4cbc3a8eaa7be0ee748e9",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    }
  ]
}