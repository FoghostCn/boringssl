{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "50db68ea_9bb75706",
        "filename": "crypto/hrss/asm/poly_rq_mul.S",
        "patchSetId": 4
      },
      "lineNbr": 336,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "It\u0027s probably also an actual ABI violation, although I don\u0027t know if the ABIs actually bother to say you can\u0027t randomly make %rsp to point into the heap. :-)\n\n(The ABI does talk about how space below %rsp and red zone may be used by signal handlers. Though I forget if signal handlers normally use a separate stack...)",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c38b9931_25214850",
        "filename": "crypto/hrss/asm/poly_rq_mul.S",
        "patchSetId": 4
      },
      "lineNbr": 336,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "I mean, %rsp is always pointing into the heap from _someone\u0027s_ perspective: our stack is the kernel\u0027s heap! But yea, we would need to add the red-zone too if doing this.",
      "parentUuid": "50db68ea_9bb75706",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ce02f3d_284fe74c",
        "filename": "crypto/hrss/asm/poly_rq_mul.S",
        "patchSetId": 4
      },
      "lineNbr": 338,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "I think this and the scratch space might be 32+32+2400 bytes too high?\n\nThe preamble allocates 6144+6144+12288+512. This code then skips the first 6144 as part of setting up.\n\nThen LHS line 1530 allocates another 9408 and enters loop karatsuba_loop_4eced63f144beffcb0247f9c6f67d165, which runs 4 times. Inside karatsuba_loop_4eced63f144beffcb0247f9c6f67d165, we start line 1536 by allocating 32 bytes (scary...)\n\nThen in 1821, still in the loop, we deallocate that 32 bytes and immediately reallocate it.\n\nIt\u0027s deallocated again at 2108, and we enter innerloop_4eced63f144beffcb0247f9c6f67d165, which fortunately doesn\u0027t touch the stack.\n\nThen at 4193, still in karatsuba_loop_4eced63f144beffcb0247f9c6f67d165, we allocate 32 bytes again, only to deallocate it at line 4782, immediately before exiting the loop. Thankfully, this means the loop\u0027s allocation is net 0, but max 32.\n\nThen at 4789, we deallocate 9408 bytes and allocate 2400 bytes. That allocation lasts to the end.\n\nTwo of the three 32-byte allocations just restore the first one. The 2400 allocation is smaller than the 9408+32 maximum inside the loop.\n\n(Probably should double-check with valgrind.)",
      "range": {
        "startLine": 338,
        "startChar": 6,
        "endLine": 338,
        "endChar": 39
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c117d8d1_dc92312d",
        "filename": "crypto/hrss/asm/poly_rq_mul.S",
        "patchSetId": 4
      },
      "lineNbr": 338,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "It never crossed my mind that the code might deallocate stack before the end. I just grepped for \u0027sub.*rsp\u0027 and added up the amounts.\n\nI think you\u0027re correct, have trimmed the size accordingly, and added a test that the code doesn\u0027t write off the end of the scratch space.",
      "parentUuid": "7ce02f3d_284fe74c",
      "range": {
        "startLine": 338,
        "startChar": 6,
        "endLine": 338,
        "endChar": 39
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "35c5fd9e_fd71b96f",
        "filename": "crypto/hrss/asm/poly_rq_mul.S",
        "patchSetId": 4
      },
      "lineNbr": 1828,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "I assume this code was originally generated by some tool...",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8440753f_7ce6934a",
        "filename": "crypto/hrss/asm/poly_rq_mul.S",
        "patchSetId": 4
      },
      "lineNbr": 1828,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "Yea, I think it\u0027s a big ball of Python code that prints assembly. Have removed this obvious no-op.",
      "parentUuid": "35c5fd9e_fd71b96f",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eac8e3a2_a27381b7",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 1226,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "C and especially C++ has some rather unhelpful rules when it comes to taking pointers to union arms you haven\u0027t written to, but it\u0027s probably fine since we only ever activate one arm. :-) I think a lot of our union uses are secretly invalid.",
      "range": {
        "startLine": 1226,
        "startChar": 2,
        "endLine": 1226,
        "endChar": 9
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44a9a5d5_a7c6b975",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 1934,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "WDYT about this helper function? https://boringssl-review.googlesource.com/c/boringssl/+/48405",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "75e8310f_da33a4de",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 1934,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "44a9a5d5_a7c6b975",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "279f7b99_7b2a7dad",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 1949,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "Optional: One downside is the compiler can no longer reduce stack space based on liveness. (Though I doubt the compiler was actually smart enough to do that.) In particular, assuming poly_invert works in-place, pfg_phi1 and pfg_phi1_inverse could be merged.",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7bea57ea_d0e0cf27",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 1949,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "Yep. When doing this I considered playing compiler and doing the \"register\" allocation by hand, but decided against. Certainly in this CL, anyway.\n\nIt would save some cache pressure, but at the cost of reducing readability, which already suffers a little here from not declaring variables near their use any longer. Decided to leave that on the table.",
      "parentUuid": "279f7b99_7b2a7dad",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "174a8aec_efdef93d",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 2033,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "Optional: Also in the vein of losing the compiler\u0027s ability to help us, if we interleave the poly_marshal_mod3 calls with the corresponding SHA256_Update calls below, m_bytes and r_bytes could be merged.\n\nIf we want to be extra clever, we can reduce four polys to two with:\n\n  SHA256_Init(\u0026vars-\u003ehash_ctx);\n  SHA256_Update(\u0026vars-\u003ehash_ctx, kSharedKey, sizeof(kSharedKey));\n  \n  // Compute and hash m.\n  poly_short_sample(\u0026vars-\u003etmp, in);\n  poly_marshal_mod3(vars-\u003ebytes, \u0026vars-\u003etmp);\n  SHA256_Update(\u0026vars-\u003ehash_ctx, vars-\u003ebytes, sizeof(vars-\u003ebytes));\n  poly_lift(\u0026vars-\u003em_lifted, \u0026vars-\u003etmp);\n\n  // Compute and hash r.\n  poly_short_sample(\u0026vars-\u003etmp, in + HRSS_SAMPLE_BYTES);\n  poly_marshal_mod3(vars-\u003ebytes, \u0026vars-\u003etmp);\n  SHA256_Update(\u0026vars-\u003ehash_ctx, vars-\u003ebytes, sizeof(vars-\u003ebytes));\n  \n  // Compute prh + m.\n  poly_mul(\u0026vars-\u003escratch, \u0026vars-\u003etmp, \u0026vars-\u003etmp, \u0026pub-\u003eph);\n  for (unsigned i \u003d 0; i \u003c N; i++) {\n    vars-\u003etmp.v[i] +\u003d vars-\u003em_lifted.v[i];\n  }\n  \n  poly_marshal(out_ciphertext, \u0026vars-\u003eprh_plus_m);\n  SHA256_Update(\u0026vars-\u003ehash_ctx, out_ciphertext, POLY_BYTES);\n  SHA256_Final(out_shared_key, \u0026vars-\u003ehash_ctx);\n\nAnd really vars-\u003ebytes could just be part of vars-\u003escratch.\n\nThis might be too clever. :-) (Comments may be wrong. I\u0027ve entirely forgotten how this algorithm works and the piecing it together from the references is a little difficult.)",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a33b59ff_5d40d876",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 2033,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "174a8aec_efdef93d",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "134e5800_ba0f2201",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 2065,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "Optional: This one might actually be sacrificing optimizations the compiler was previously helping us with, if its escape analysis is good enough.\n\nWe have a pretty tight chain of single-use temporaries from f -\u003e cf -\u003e cf3 -\u003e m3 -\u003e m. r3 is also thrown away immediately. So if we\u0027re willing to be a bit clever, we can write:\n\n    struct poly tmp;\n    struct poly3 tmp3;\n    ...\n\n  // Compute tmp3 \u003d c * f as a poly3.\n  poly_from_poly3(\u0026vars-\u003etmp, \u0026priv-\u003ef);\n  poly_mul(\u0026vars-\u003escratch, \u0026vars-\u003etmp, \u0026vars-\u003ec, \u0026vars-\u003etmp);\n  poly3_from_poly(\u0026vars-\u003etmp3, \u0026vars-\u003etmp);\n  \n  // Compute m \u003d c * f * f_inverse. Note that tmp3 is not\n  // reduced mod Φ(N). That reduction is deferred.\n  HRSS_poly3_mul(\u0026vars-\u003etmp3, \u0026vars-\u003etmp3, \u0026priv-\u003ef_inverse);\n  poly_from_poly3(\u0026vars-\u003em, \u0026vars-\u003etmp3);\n  \n  poly_lift(\u0026vars-\u003etmp, \u0026vars-\u003em);\n  for (unsigned i \u003d 0; i \u003c N; i++) {\n    vars-\u003er.v[i] \u003d vars-\u003ec.v[i] - vars-\u003etmp.v[i];\n  }\n  poly_mul(\u0026vars-\u003escratch, \u0026vars-\u003er, \u0026vars-\u003er, \u0026priv-\u003eph_inverse);\n  poly_mod_phiN(\u0026vars-\u003er);\n  poly_clamp(\u0026vars-\u003er);\n  \n  crypto_word_t ok \u003d poly3_from_poly_checked(\u0026vars-\u003er3, \u0026vars-\u003er);\n\nThere\u0027re probably other non-overlapping lifetimes. Dunno if they, or this one, is worth it. \n\n(Comments may be wrong. I\u0027ve forgotten how this works.)",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5167b6a1_21faf8b3",
        "filename": "crypto/hrss/hrss.c",
        "patchSetId": 4
      },
      "lineNbr": 2065,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "134e5800_ba0f2201",
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "88b2af5f_5af1ba34",
        "filename": "crypto/hrss/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 59,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "Hehe, maybe time to write the s/|/`/ regex. :-) Or maybe I\u0027ll do it as part of convert_comments.go so it doesn\u0027t hit actual code.",
      "range": {
        "startLine": 59,
        "startChar": 31,
        "endLine": 59,
        "endChar": 32
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b303b967_23b22c33",
        "filename": "crypto/hrss/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 59,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "(In my mind there are |names| that can be linked to and `code samples in a fixed-width font`, that can\u0027t.)",
      "parentUuid": "88b2af5f_5af1ba34",
      "range": {
        "startLine": 59,
        "startChar": 31,
        "endLine": 59,
        "endChar": 32
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "55a008a5_0581d39d",
        "filename": "crypto/hrss/internal.h",
        "patchSetId": 4
      },
      "lineNbr": 59,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-14T21:20:45Z",
      "side": 1,
      "message": "Ah. Rust does [`Foo`] which seems tedious and overlaps with other syntax. I always figured we can also just parse out names from code samples. Any code that parses as a name may as well link to that name.\n\nAlso the pipes can get little awkward in more mathy code since they look like absolute value. :-)",
      "parentUuid": "b303b967_23b22c33",
      "range": {
        "startLine": 59,
        "startChar": 31,
        "endLine": 59,
        "endChar": 32
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3223b84b_7ff412d1",
        "filename": "include/openssl/hrss.h",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-02T19:14:22Z",
      "side": 1,
      "message": "Nitpick: \"It returns one on success or zero on malloc failure\" for consistency.\n\n(Probably clearer anyway. It\u0027s not immediately obvious that NOT malloc_failure \u003d\u003e success.)",
      "range": {
        "startLine": 82,
        "startChar": 28,
        "endLine": 82,
        "endChar": 79
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85ce9f2c_7a5ba001",
        "filename": "include/openssl/hrss.h",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-12T19:42:34Z",
      "side": 1,
      "message": "My worry is that \"success\" is ambiguous. Does it mean that malloc didn\u0027t fail (it does) or that the ciphertext was actually decoded? Have tried to expand on that.",
      "parentUuid": "3223b84b_7ff412d1",
      "range": {
        "startLine": 82,
        "startChar": 28,
        "endLine": 82,
        "endChar": 79
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a2506360_254389d7",
        "filename": "include/openssl/hrss.h",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-07-14T21:20:45Z",
      "side": 1,
      "message": "Oh whoops, totally missed that. New version looks reasonable.\n\nIt is odd that we have so many different variations on this. In P-256, we just treat publicly invalid inputs as an error, and expect callers to handle this.\n\nX25519 is a complete function, but only after you\u0027ve ensured the input is 32 bytes. Callers usually report an error there. We do for TLS. Beyond that, X25519 is happy to mask off the high bit, accept non-canonical inputs, and do something useful with it. But it has an optional failure return for contributory behavior, which TLS checks but I think no longer requires in 1.3? (I forget.)\n\nAnd then this function takes a variable-length input, but \"accepts\" invalid ciphertexts, even to the point of invalid lengths, feeding the variable-length thing to the HMAC (but still injective). Except since TLS needs to divide up into an X25519 and HRSS half, we end up checking the length anyway and treating that as an error. Whereas a non-hybrid HRSS user might leave it to the function and do something else.\n\n*shrug* I suppose easiest is to leave it alone here. Hopefully whenever something is standardized here, we\u0027ll all agree on something. :-)",
      "parentUuid": "85ce9f2c_7a5ba001",
      "range": {
        "startLine": 82,
        "startChar": 28,
        "endLine": 82,
        "endChar": 79
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8f76fc5_0669e925",
        "filename": "include/openssl/hrss.h",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 5070
      },
      "writtenOn": "2021-07-15T18:50:17Z",
      "side": 1,
      "message": "The hope is always to write an maximally infallible function, I guess, and then reality chips away at it.",
      "parentUuid": "a2506360_254389d7",
      "range": {
        "startLine": 82,
        "startChar": 28,
        "endLine": 82,
        "endChar": 79
      },
      "revId": "e5b5ef8e04803569e8e18f0d38b98bb5a68e3b24",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}