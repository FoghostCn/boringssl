{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a45f67b5_ec1bb1e2",
        "filename": "crypto/fipsmodule/sha/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 14196
      },
      "writtenOn": "2023-11-28T22:09:24Z",
      "side": 1,
      "message": "Yeah, ok, I know naming is the worst darn thing to bikeshed on but \"SPLIT\" doesn\u0027t really do it for me, maybe \"_HW\" - but probably a tiny little comment in here explaining what the define sets up.",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5af1b445_d1583bfd",
        "filename": "crypto/fipsmodule/sha/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-28T22:52:47Z",
      "side": 1,
      "message": "We usually name these after the functions they provide, so `SHA_ASM_HW` makes some sense.\n\nIf we kept the `_nohw` ones unsuffixed, that would further match the convention, but I guess that makes the C side kinda annoying because we\u0027d squat the unsuffixed name.\n\nBut this abstraction seems also a little odd...\n\n* For aarch64, it happens that all three go split together, but that wasn\u0027t true until somewhat recently, when we added SHA-512 assembly.\n* For armv7, the split is not universal\n* For non-Arm platforms, we will, I assume need a split, but the capability check is different.",
      "parentUuid": "a45f67b5_ec1bb1e2",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2215dfb_22f59b5c",
        "filename": "crypto/fipsmodule/sha/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-28T23:25:26Z",
      "side": 1,
      "message": "\u003e If we kept the _nohw ones unsuffixed, that would further match the convention, but I guess that makes the C side kinda annoying because we\u0027d squat the unsuffixed name.\n\nWe need the unsuffixed name to be used for the function that does the dispatching, as there are many callers of `shaXXX_block_data_order`. \n\nExactly because each architectures\u0027 implementation will get split differently, I chose the suffix `_SPLIT` instead of `_HW`. My intention is to do all of sha{1,256,512}_block_data_order per architecture (now Aarch64, next x86-64).\n\nSince we need to change the coverage test in a way that\u0027s going to require more conditional-on-target-arch logic anyway, I\u0027ll work on that and the x86-64 a bit and see if a better solution comes to me in the process.",
      "parentUuid": "5af1b445_d1583bfd",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47964997_fd993611",
        "filename": "crypto/fipsmodule/sha/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 14196
      },
      "writtenOn": "2023-11-28T23:36:44Z",
      "side": 1,
      "message": "And we still haven\u0027t decided that if your armv7 doesn\u0027t have neon it can just do it in C... right?",
      "parentUuid": "d2215dfb_22f59b5c",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be7a78a7_246a813d",
        "filename": "crypto/fipsmodule/sha/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 14196
      },
      "writtenOn": "2023-11-28T23:41:56Z",
      "side": 1,
      "message": "\u003eIf we kept the _nohw ones unsuffixed, that would further match the convention, but I guess that makes the C side kinda annoying because we\u0027d squat the unsuffixed name.\n\nor we do\n\nfoo_bar_baz_asm\n\nfor generic assembly implementations and\n\nfoo_bar_baz_asm_[hw|accel]\n\nfor hw accellerated.",
      "parentUuid": "47964997_fd993611",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0aa1e80e_555921fb",
        "filename": "crypto/fipsmodule/sha/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-30T18:28:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "be7a78a7_246a813d",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff98d3fd_868361b7",
        "filename": "crypto/fipsmodule/sha/sha1.c",
        "patchSetId": 1
      },
      "lineNbr": 196,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-28T22:52:47Z",
      "side": 1,
      "message": "C code should never access these capabilities directly. That won\u0027t interact correctly with `CRYPTO_library_init` and static capabilities. Instead, add companion functions to `CRYPTO_is_ARMv8_AES_capable` in `crypto/internal.h` and call that.",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "090a46d8_b153f295",
        "filename": "crypto/fipsmodule/sha/sha1.c",
        "patchSetId": 1
      },
      "lineNbr": 196,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-30T18:28:27Z",
      "side": 1,
      "message": "PTAL at how I did it and see if that works well for you. Note that I intentionally avoided adding any static feature detection logic because static feature detection wasn\u0027t being done already and that should be handled separately in case there are issues. (I have had issues on the Rust side with static feature detection that warrant caution.)",
      "parentUuid": "ff98d3fd_868361b7",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "163e2692_30524f76",
        "filename": "crypto/fipsmodule/sha/sha1.c",
        "patchSetId": 1
      },
      "lineNbr": 196,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-30T18:38:05Z",
      "side": 1,
      "message": "I mean, right now this is about half static feature detection and half not, depending on which features we happened to already have, which just leaves things inconsistent. I\u0027d rather we not introduce an inconsistency and at least stick to having wrappers in crypto/internal.h. One place to look over the bits being correct, etc.\n\nAlthough adding the static feature detection half tends to be pretty straightforward. ACLE is well-defined and the GCC #defines for x86 tend to be self-explanatory.\n\n\u003e I have had issues on the Rust side with static feature detection that warrant caution.\n\nCould you elaborate on this? It\u0027s been pretty smooth sailing for us, at least with the patterns we\u0027ve established. Not sure what Rust is doing.",
      "parentUuid": "090a46d8_b153f295",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a6fefc5_6b55e074",
        "filename": "crypto/fipsmodule/sha/sha_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-28T22:52:47Z",
      "side": 1,
      "message": "s/Sha/SHA/\n\nDitto for the others.",
      "range": {
        "startLine": 43,
        "startChar": 19,
        "endLine": 43,
        "endChar": 23
      },
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ecd7094_81ed6deb",
        "filename": "crypto/fipsmodule/sha/sha_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-30T18:28:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5a6fefc5_6b55e074",
      "range": {
        "startLine": 43,
        "startChar": 19,
        "endLine": 43,
        "endChar": 23
      },
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13f98053_703edc9f",
        "filename": "crypto/fipsmodule/sha/sha_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-28T22:52:47Z",
      "side": 1,
      "message": "This will fail if the host device doesn\u0027t support the CPU feature. Instead, this should work like the other ABI tests, where the tests correctly condition themselves on what the function needs.",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eba8087d_c9365859",
        "filename": "crypto/fipsmodule/sha/sha_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-30T18:28:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "13f98053_703edc9f",
      "revId": "4829d402ad6459d2d1c81bb4db6cbb1792a52ef8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}