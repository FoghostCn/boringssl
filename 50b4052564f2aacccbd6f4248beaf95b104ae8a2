{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "741900a1_78d30300",
        "filename": "crypto/asn1/asn1_lib.c",
        "patchSetId": 5
      },
      "lineNbr": 283,
      "author": {
        "id": 14196
      },
      "writtenOn": "2022-10-25T21:04:42Z",
      "side": 1,
      "message": "no, it can\u0027t represent strings that exceed int - 1",
      "range": {
        "startLine": 283,
        "startChar": 2,
        "endLine": 283,
        "endChar": 3
      },
      "revId": "50b4052564f2aacccbd6f4248beaf95b104ae8a2",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed40efc0_bab8a4c2",
        "filename": "crypto/asn1/asn1_lib.c",
        "patchSetId": 5
      },
      "lineNbr": 283,
      "author": {
        "id": 5415
      },
      "writtenOn": "2022-11-06T15:41:11Z",
      "side": 1,
      "message": "Oh hmm. Actually, now that I look at it again, this is subtle:\n\n- `ASN1_STRING` itself doesn\u0027t require `len + 1` fit in `int`, only `len`.\n- However, a priori `len + 1` in `ossl_ssize_t` is not *necessarily* safe. `INT_MAX - 1` made it okay, because `ssize_t` is at least as big as `int`. But it\u0027s a little silly.\n- Whether all other code in the library tolerates an `INT_MAX` length, who knows? Though it\u0027s also made entirely of overflows anyway, at least until we redo it all with CBB/CBS. For tasn_dec.c, we set a limit of `INT_MAX / 2` as a \"this library is full of overflows and we don\u0027t trust it\" theory.\n\nThoughts? I\u0027m thinking the two reasonable options are:\n\na. The true limit is `INT_MAX` so check `INT_MAX`. Or...\nb. Do the same `INT_MAX / 2` limit, with an explanation that it\u0027s because crypto/asn1 and crypto/x509 are known to be made of overflow bugs.\n\n(a) feels more Correct, but, e.g, `i2c_ASN1_BIT_STRING` doesn\u0027t handle overflow. `i2c_ASN1_INTEGER` does, though. And I\u0027m sure there are overflows all throughout the library if your `ASN1_STRING` is too big. (Good news is it\u0027s not reachable from parsing because of tasn_dec.c\u0027s limit.)",
      "parentUuid": "741900a1_78d30300",
      "range": {
        "startLine": 283,
        "startChar": 2,
        "endLine": 283,
        "endChar": 3
      },
      "revId": "50b4052564f2aacccbd6f4248beaf95b104ae8a2",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "711effef_a21dd7a6",
        "filename": "crypto/asn1/asn1_lib.c",
        "patchSetId": 5
      },
      "lineNbr": 283,
      "author": {
        "id": 14196
      },
      "writtenOn": "2022-11-06T16:02:44Z",
      "side": 1,
      "message": "All it really needs the +1 for is the 0 byte on the end, so you need the INT_MAX - 1, since that\u0027s the real limit for \"len\" - which does not store the allocated size, it always stores the allocated size - 1, because it\u0027s strlen, not size of array. \n\nSo I think the existing way is fine, other than the comment about an ASN1_STRING, It doesn\u0027t care about overflowing the int - but the string itself has a 0 byte added.",
      "parentUuid": "ed40efc0_bab8a4c2",
      "range": {
        "startLine": 283,
        "startChar": 2,
        "endLine": 283,
        "endChar": 3
      },
      "revId": "50b4052564f2aacccbd6f4248beaf95b104ae8a2",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9124753a_f364b0b3",
        "filename": "crypto/asn1/asn1_lib.c",
        "patchSetId": 5
      },
      "lineNbr": 283,
      "author": {
        "id": 5415
      },
      "writtenOn": "2022-11-06T16:15:10Z",
      "side": 1,
      "message": "I\u0027m not sure `ASN1_STRING`, on its own, *actually* needs the -1. After this function\u0027s done its thing, it entirely forgets the trailing NUL. We can\u0027t even rely on an `ASN1_STRING` to have it. (CVE-2021-3712)\n\nSo my claim is that we actually only need to check:\n\n1. `len + 1`, in `size_t` space, doesn\u0027t overflow\n2. `len` fits in `int`\n\n(And then 1 is redundant with 2 because `INT_MAX \u003c SIZE_MAX - 1`.)\n\nI.e. actually the comment was right, not the code. (Except *other* code is wrong and may break given an `INT_MAX`-sized `ASN1_STRING`, and so maybe we want to be more conservative. Or maybe we should just fix that code...)",
      "parentUuid": "711effef_a21dd7a6",
      "range": {
        "startLine": 283,
        "startChar": 2,
        "endLine": 283,
        "endChar": 3
      },
      "revId": "50b4052564f2aacccbd6f4248beaf95b104ae8a2",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "afcb90f0_3ab79247",
        "filename": "crypto/asn1/asn1_lib.c",
        "patchSetId": 5
      },
      "lineNbr": 283,
      "author": {
        "id": 14196
      },
      "writtenOn": "2022-11-07T12:25:55Z",
      "side": 1,
      "message": "Fundamentally, I\u0027d love to just say \"fix the other code\" and not depend on the 0 byte being there.  Sadly this has been this way long enough that I expect that\u0027s very pervasive, and happening a lot outside of boring even if we fix our own\nuses in crypto/asn1 and crypto/x509 and friends.\n\nIn a perfect world I\u0027d love to get rid of the 0 byte crutch in here, but I don\u0027t think we can without introducing a lot of potential for danger with users outside who are unwittingly depending on that behaviour.\n\nso tl;dr, yeah, since the allocations happen in size_t space, yes, we should just check that len fits in an int.",
      "parentUuid": "9124753a_f364b0b3",
      "range": {
        "startLine": 283,
        "startChar": 2,
        "endLine": 283,
        "endChar": 3
      },
      "revId": "50b4052564f2aacccbd6f4248beaf95b104ae8a2",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2c6f353_8bff5300",
        "filename": "crypto/asn1/asn1_lib.c",
        "patchSetId": 5
      },
      "lineNbr": 283,
      "author": {
        "id": 5415
      },
      "writtenOn": "2022-11-14T17:55:23Z",
      "side": 1,
      "message": "\u003e In a perfect world I\u0027d love to get rid of the 0 byte crutch in here, but I don\u0027t think we can without introducing a lot of potential for danger with users outside who are unwittingly depending on that behaviour.\n\nAgreed, yeah, I was just arguing that we don\u0027t actually need len+1 to fit in int because nothing actually acts on it.\n\n\u003e so tl;dr, yeah, since the allocations happen in size_t space, yes, we should just check that len fits in an int.\n\nAck. How\u0027s this version look?",
      "parentUuid": "afcb90f0_3ab79247",
      "range": {
        "startLine": 283,
        "startChar": 2,
        "endLine": 283,
        "endChar": 3
      },
      "revId": "50b4052564f2aacccbd6f4248beaf95b104ae8a2",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}