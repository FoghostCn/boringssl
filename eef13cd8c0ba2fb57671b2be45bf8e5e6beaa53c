{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9a7d5267_f87e6e8d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-12T16:08:09Z",
      "side": 1,
      "message": "Kind ping on this :) thnaks!",
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f91bc258_20f44fdb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-07-14T18:37:27Z",
      "side": 1,
      "message": "Sorry for how tardy my response is here. ðŸ˜ž",
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd8d1c15_f317f3cd",
        "filename": "rust/bssl-crypto/src/aead/aes_gcm_siv.rs",
        "patchSetId": 11
      },
      "lineNbr": 23,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-07-14T18:37:27Z",
      "side": 1,
      "message": "How do we expect this API to be used? I noticed it\u0027s under the `aead::aes_gcm_siv` module. Is it expected that Rust imports the individual function, or imports the crate and calls it as `aes_gcm_siv::new_aes_128_gcm_siv`? The latter is kinda wordy.\n\n(Would it make sense to just put all the AEADs in the `aead` module?)",
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a466f1a5_86b739e4",
        "filename": "rust/bssl-crypto/src/aead/aes_gcm_siv.rs",
        "patchSetId": 11
      },
      "lineNbr": 23,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-25T23:45:26Z",
      "side": 1,
      "message": "My thinking was to keep each primitive contained in its own mod, but I agree thats too wordy. Moved into aead mod directly, and we can revisit in the future if this is expanded to support further AEAD\u0027s",
      "parentUuid": "bd8d1c15_f317f3cd",
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7fb6c5b_950556e4",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 18,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-07-14T18:37:27Z",
      "side": 1,
      "message": "To be consistent with https://boringssl-review.googlesource.com/c/boringssl/+/60546, let\u0027s drop all the mentions of \"BoringSSL implemented\" references. That\u0027s all implicit from the fact that you\u0027re using bssl-crypto.",
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "efb1aa84_a48fe4cf",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 18,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-25T23:45:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d7fb6c5b_950556e4",
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91521a73_2a3ec7a3",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 33,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-07-14T18:37:27Z",
      "side": 1,
      "message": "This is an odd calling convention for an in-place encrypt. Usually the idea with in-place encrypt or decrypt is that the buffer is managed however the caller wants. I.e. it would want to take a mutable slice of some sort. This one forces it to be a `Vec`.\n\nFor example, if you\u0027re decrypting TLS packets, your input will be a slice of a much larger packet. This API is actually incompatible with in-place operation because it requires the caller move it into a `Vec` first. At that point, it\u0027s more efficient to take the input as `\u0026[u8]` and put the output in a separate `Vec\u003cu8\u003e`.",
      "range": {
        "startLine": 33,
        "startChar": 22,
        "endLine": 33,
        "endChar": 40
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d344fdf_aac85c85",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 33,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-25T23:45:26Z",
      "side": 1,
      "message": "ahh okay, good point, in that case will update to take the input as a slice and output a seperate `Vec\u003cu8\u003e`. \n\nWould another option be to take a mutable slice `\u0026mut [u8]` and a `size_t len` as inputs, where `len` contains the length of the data to be encrypted within the slice. The API would then return an error code in the case that the length of the slice minus the length of the data is not enough to hold the tag for the aead?\n\nThe rust crypto traits solve this by using a `\u0026mut dyn Buffer` trait bound to the input buffer, which can be provided by using either a `BytesMut` type, which would require us taking on a 3p dependency, or a `Vec\u003cu8\u003e` https://docs.rs/aes-gcm-siv/latest/aes_gcm_siv/trait.AeadInPlace.html#",
      "parentUuid": "91521a73_2a3ec7a3",
      "range": {
        "startLine": 33,
        "startChar": 22,
        "endLine": 33,
        "endChar": 40
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a67429c_444fb77b",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 33,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-26T00:00:53Z",
      "side": 1,
      "message": "On second thought, a potentially better API design could be to separate the resulting tag from the input data? So for example, take a mutable slice as input which contains just the data to be encrypted. Then this operation would encrypt that data in-place and return the tag separately?\n\nSimilarly for decrypt we could accept the tag as a separate input parameter, and then just decrypt the provided input slice in-place on successful tag verification",
      "parentUuid": "9d344fdf_aac85c85",
      "range": {
        "startLine": 33,
        "startChar": 22,
        "endLine": 33,
        "endChar": 40
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ccd50c8_86f10e28",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 33,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-27T16:39:45Z",
      "side": 1,
      "message": "Updated to take an input slice and return the encrypted data + tag in a `Result\u003cVec\u003cu8\u003e\u003e`. For decrypt the input is just decrypted in-place for the provided mutable slice.",
      "parentUuid": "3a67429c_444fb77b",
      "range": {
        "startLine": 33,
        "startChar": 22,
        "endLine": 33,
        "endChar": 40
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1c021d5_1bb8ad17",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 33,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-08-09T18:19:26Z",
      "side": 1,
      "message": "discussed this in below comment, so resolving this one.",
      "parentUuid": "3ccd50c8_86f10e28",
      "range": {
        "startLine": 33,
        "startChar": 22,
        "endLine": 33,
        "endChar": 40
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58018f9a_53901f17",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 63,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-07-14T18:37:27Z",
      "side": 1,
      "message": "This kind of API is an anti-pattern[*] for us, which is why we don\u0027t have such an API for AEADs in C. (There are a few places where we do, but they\u0027re all for OpenSSL compatibility and usually have warnings not to use them.)\n\nThe problems are:\n\n* It means the caller pulls in every AEAD we implement, whether they use it or not\n\n* Different caller have different needs. One application may need SHA-1 support for legacy compatibility, while another caller may have security requirements incompatible with SHA-1. APIs like this make it very easy for unwanted hashes to be reachable to callers.\n\n* It makes it much more difficult to statically check what algorithms are used by what callers.\n\nInstead, each AEAD should be its own symbol. When callers want to dispatch between a couple algorithms, it should be up to the caller to collect the algorithms they accept and dispatch between them. This avoids both these problems.\n\n[*] Admittedly our SPKI and PKCS#8 parsers implicitly have this property. One thing I\u0027d like to do is rework them so the caller explicitly says \"parse SPKI, I am okay with these key types\".",
      "range": {
        "startLine": 63,
        "startChar": 42,
        "endLine": 63,
        "endChar": 61
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbc46610_0268c4b4",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 63,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-25T23:45:26Z",
      "side": 1,
      "message": "This is the private internal implementation of the AEAD, which handles calling into the boringssl API. Publicly each AEAD API is exposed with its own symbol. I think of this as similar to how in boringssl every AEAD is a const type, which is passed into `EVP_AEAD_CTX_new`, `EVP_AEAD_CTX_seal`, and `EVP_AEAD_CTX_open`, which are functions shared by all of the different AEAD implementations. \n\nSee the following chained CL for how this generic private implementation can be used to simplify implementing each AEAD which has its own separate public API: https://boringssl-review.googlesource.com/c/boringssl/+/60405/4\n\nI think the statically checking which algorithms are used by each callers is still easy, since that can be checked by which public API the callers are using.",
      "parentUuid": "58018f9a_53901f17",
      "range": {
        "startLine": 63,
        "startChar": 42,
        "endLine": 63,
        "endChar": 61
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8715e04e_839788a2",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 63,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-27T20:52:22Z",
      "side": 1,
      "message": "I updated this to be a generic parameter on the `new` rather than an enum input, which makes it more clear that this is a different symbol for each aead algorithm just re-using the same code to make the unsafe calls to BoringSSL. Also ensures the key sizes are correct for the given algorithm",
      "parentUuid": "fbc46610_0268c4b4",
      "range": {
        "startLine": 63,
        "startChar": 42,
        "endLine": 63,
        "endChar": 61
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "44950a3f_8965438f",
        "filename": "rust/bssl-crypto/src/aead/mod.rs",
        "patchSetId": 11
      },
      "lineNbr": 63,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-08-09T18:19:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8715e04e_839788a2",
      "range": {
        "startLine": 63,
        "startChar": 42,
        "endLine": 63,
        "endChar": 61
      },
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "113fe03a_97014174",
        "filename": "rust/bssl-crypto/src/lib.rs",
        "patchSetId": 11
      },
      "lineNbr": 29,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-07-14T18:37:27Z",
      "side": 1,
      "message": "(The convention here will have changed a bit when you rebase.)",
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "850626ba_99774f86",
        "filename": "rust/bssl-crypto/src/lib.rs",
        "patchSetId": 11
      },
      "lineNbr": 29,
      "author": {
        "id": 15751
      },
      "writtenOn": "2023-07-25T23:45:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "113fe03a_97014174",
      "revId": "eef13cd8c0ba2fb57671b2be45bf8e5e6beaa53c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}