{
  "comments": [
    {
      "key": {
        "uuid": "71fdc393_f7a67de9",
        "filename": "crypto/fipsmodule/aes/aes.c",
        "patchSetId": 1
      },
      "lineNbr": 814,
      "author": {
        "id": 6651
      },
      "writtenOn": "2018-05-04T16:02:42Z",
      "side": 1,
      "message": "Typo; shouldn\u0027t this be asm_AES_*?",
      "range": {
        "startLine": 814,
        "startChar": 34,
        "endLine": 814,
        "endChar": 43
      },
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3df3a49_ac5761fa",
        "filename": "crypto/fipsmodule/aes/aes.c",
        "patchSetId": 1
      },
      "lineNbr": 814,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-05-07T18:15:46Z",
      "side": 1,
      "message": "Yep, thanks.",
      "parentUuid": "71fdc393_f7a67de9",
      "range": {
        "startLine": 814,
        "startChar": 34,
        "endLine": 814,
        "endChar": 43
      },
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "909329e8_6919c2a3",
        "filename": "crypto/fipsmodule/aes/aes.c",
        "patchSetId": 1
      },
      "lineNbr": 820,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-05-04T17:47:14Z",
      "side": 1,
      "message": "(I suspect every AArch64 configuration we care about actually defines __ARM_FEATURE_CRYPTO and so we statically know hwaes_capable returns true, but whatever.)\n\nThis doesn\u0027t kick in aes_hw_* for AArch64 though. That codepath is still using the built-in one. I guess you could add an if defined(HWAES) at the top of each of those functions. Or perhaps those functions could define static void asm_AES_encrypt (silly name... #defines?) and then these wrappers can just be:\n\nvoid AES_encrypt(...) {\n  if (hwaes_capable()) {\n    aes_hw_encrypt(in, out, key);\n    return;\n  }\n  asm_AES_encrypt(in, out, key);\n}\n\n(Hopefully, on platforms without any assembly at all, the compiler is smart enough to first optimize out that conditional and then inline the static asm_AES_encrypt into the wrapper.)",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "765828d8_04602ada",
        "filename": "crypto/fipsmodule/aes/aes.c",
        "patchSetId": 1
      },
      "lineNbr": 820,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-05-07T18:15:46Z",
      "side": 1,
      "message": "\u003e This doesn\u0027t kick in aes_hw_* for AArch64 though.\n\nMy thought for AArch64 was that asm_AES_encrypt should be called aes_nohw_encrypt (and so on), and then the C functions can have the same name on platforms, like AArch64, where we don\u0027t have an assembly version.\n\nThis change got large enough to want to defer that though.",
      "parentUuid": "909329e8_6919c2a3",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6754a6a7_05145133",
        "filename": "crypto/fipsmodule/aes/asm/aesni-x86_64.pl",
        "patchSetId": 1
      },
      "lineNbr": 209,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-05-04T17:47:14Z",
      "side": 1,
      "message": "This is such a fantastically useful line of code... :-)",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1c798b0d_eed39f40",
        "filename": "crypto/fipsmodule/aes/asm/aesni-x86_64.pl",
        "patchSetId": 1
      },
      "lineNbr": 209,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-05-07T18:15:46Z",
      "side": 1,
      "message": "Yep!",
      "parentUuid": "6754a6a7_05145133",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "23e7a5da_6964879a",
        "filename": "crypto/fipsmodule/aes/mode_wrappers.c",
        "patchSetId": 1
      },
      "lineNbr": 76,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-05-04T17:47:14Z",
      "side": 1,
      "message": "This seems a bit off. I\u0027m guessing the motivation was to deal with the hw/non-hw incompatibility? There aren\u0027t any platforms with asm_AES_cbc_encrypt (just Intel) but not HWAES. I think this change will lose the asm_AES_cbc_encrypt optimization on Intel w/o AESNI, and fail to compile on platforms without HWAES.\n\nPerhaps:\n\nvoid AES_cbc_encrypt(...) {\n  if (hwaes_capable()) {\n    aes_hw_cbc_encrypt(...);\n    return;\n  }\n#if !NO_ASM \u0026\u0026 (X86_64 || X86)\n  asm_AES_cbc_encrypt(...);\n#else\n  if (enc) {\n    ...\n  } else {\n    ...\n  }\n#endif\n}\n\nThough this does have the consequence of checking hwaes_capable() a few extra times in the CBC-mode EVP_CIPHER on some platforms since AES_cbc_encrypt is actually called by EVP_CIPHER.",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e69f1112_d86d0b34",
        "filename": "crypto/fipsmodule/aes/mode_wrappers.c",
        "patchSetId": 1
      },
      "lineNbr": 76,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-05-07T18:15:46Z",
      "side": 1,
      "message": "Yep, sorry. This was a hack that I forget to come back to and address.\n\nI think this is also suitable for a follow-up change because CRYPTO_cbc128_* functions are fallbacks that are mooted by aes_AES_cbc when we have it, but EVP will call them directly. Also, we have bsaes_cbc_encrypt which is preferable to asm_AES whenever we have SSSE3, which is very common.",
      "parentUuid": "23e7a5da_6964879a",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ec6d0aa6_adcce832",
        "filename": "crypto/fipsmodule/aes/mode_wrappers.c",
        "patchSetId": 1
      },
      "lineNbr": 76,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-05-10T19:16:03Z",
      "side": 1,
      "message": "Yeah, it\u0027d be nice to have a more coherent story for AES_* and EVP_CIPHER_*. Given we keep getting random requests for AES_* to be accelerated, probably the dispatch should be shared between the two somehow.",
      "parentUuid": "e69f1112_d86d0b34",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d488183_3a52659c",
        "filename": "crypto/fipsmodule/cipher/e_aes.c",
        "patchSetId": 1
      },
      "lineNbr": 770,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-05-04T17:47:14Z",
      "side": 1,
      "message": "I certainly hope no one cares about this optimization! People often use \"ECB mode\" when they actually want the AES block operation, but in that case the generic loop over the block128_f should suffice, rather than the fancy assembly loop.\n\nBut removing that can be a separate thing I guess.",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d9a6767_57f5736b",
        "filename": "crypto/fipsmodule/cipher/e_aes.c",
        "patchSetId": 1
      },
      "lineNbr": 770,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-05-07T18:15:46Z",
      "side": 1,
      "message": "Yep, this certainly looks like a candidate for removal.",
      "parentUuid": "0d488183_3a52659c",
      "revId": "0a507036b277338dce0b600f18ec54cdd9ddd6ac",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    }
  ]
}