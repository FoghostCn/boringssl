{
  "comments": [
    {
      "key": {
        "uuid": "f8bf9cdf_2720b9d8",
        "filename": "BUILDING.md",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-08-29T19:58:17Z",
      "side": 1,
      "message": "Want a script for it?\nhttps://boringssl-review.googlesource.com/c/boringssl/+/31444\n\nDisclaimer: untested. Feel free to modify as needed. :-)\n\nWe can probably set up some CMake glue so you can even pass in -DBORINGSSL_PREFIX_SYMBOLS\u003dpath/to/symbols.txt for step two.\n\nAnd then maybe we check in some standard tooling to double-check all symbols for prefixes. Or to gather symbols, etc. And hopefully we\u0027ll eventually end up with something you can use without fuss.",
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69b131f7_71904e7a",
        "filename": "BUILDING.md",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 8959
      },
      "writtenOn": "2018-08-29T22:50:01Z",
      "side": 1,
      "message": "Oh, awesome idea! And thanks so much for writing that script!\n\nSo let me know what you\u0027re thinking related to how to incorporate this into the build. In particular, I\u0027m curious what you think about where files should go during the build and whatnot. I\u0027m thinking something like:\n\nWhen you run \u0027cmake \u003cpath-to-src\u003e -DBORINGSSL_PREFIX_SYMBOLS\u003d\u003cpath-to-symbols\u003e\u0027, the following happens:\n1. Create \"symbol_prefix_include\" directory\n2. Run the Go script, placing the generated header files in the \"symbol_prefix_include\" directory\n3. Configure Ninja/Make to add that directory to the include path",
      "parentUuid": "f8bf9cdf_2720b9d8",
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2ff85b3_afa0b047",
        "filename": "BUILDING.md",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-09-05T00:18:05Z",
      "side": 1,
      "message": "I think it\u0027s mostly a matter of how much work we want to do right away vs. how soon you want a solution. :-)\n\nWith the CL as-is, the story is: we give you -DBORINGSSL_PREFIX on the CMake side and a script. It\u0027s your responsibility to figure out the symbol list, run the script, check the generated files in somewhere, and then add -Iwhere/you/put/them into the C flags.\n\nWith some amount of CMake goo, we can improve this to what you describe with BORINGSSL_PREFIX_SYMBOLS. We\u0027d tell CMake that boringssl_prefix_symbols.h is an output which depends on the script and the supplied file and we\u0027d tell CMake to add the containing directory to the include directories.\n\nThat would save you from checking in the generated headers, but mean fighting with CMake. Fighting with CMake is a pain, so I am perfectly happy with this CL doing either of the above, depending on which you feel like doing.\n\nOf course, even with CMake goop, folks using non-CMake build systems (which is actually our usual assumption for consumers, but I gather you\u0027re just calling into CMake) have to do everything themselves. Our usual answer is generated files are pre-generated with generate_build_files.py, but we don\u0027t have a sane source for the symbol list yet (hence the dumb hack to amortize it to updates on your end for now).\n\nAfter this CL (or in the same one if you feel like it), probably the next step is to write a checker. I\u0027m thinking a Go script that uses debug/{elf,macho,pe} that takes lib{crypto,ssl}.a and checks:\n\n- All C symbols start with the passed in prefix\n- All C++ symbols have the prefix as a substring somewhere.\n\nFinally, once we somehow figure out how to generate the symbol list sanely (I\u0027m currently thinking a barebones C parser), we can stop making it your problem and, with some CMake and generate_build_files.py goop, -DBORINGSSL_PREFIX\u003dblah will Just Work. Or maybe we implement the \"build twice, sample symbols from first build\" strategy in CMake, but that doesn\u0027t work for generate_build_files.py.\n\nWDYT?",
      "parentUuid": "69b131f7_71904e7a",
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e5a39af_4c4bd400",
        "filename": "BUILDING.md",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 8959
      },
      "writtenOn": "2018-09-05T03:18:08Z",
      "side": 1,
      "message": "Sounds good to me! I\u0027m going to try to get CMake working; it\u0027ll hopefully save me time on the boringssl-sys side in the long run. If it becomes too painful, I might give up and go the easier route for the time being :)\n\nWith that said, a few questions:\n- What should we name the temporary directory in which we generate the header files?\n- How should this directory be created? Will CMake be smart enough to create build rules which create the directory itself before generating the header files?\n\nRe: Doing this in CMake: Is it acceptable, for the time being, to simply say that we only support symbol prefixing for consumers building via CMake?\n\nRe: Auto-checker and beyond: Sounds roughly good to me, although yes, I definitely want to punt on that for a future CL :)",
      "parentUuid": "f2ff85b3_afa0b047",
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "253f338f_f002a1df",
        "filename": "BUILDING.md",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 8959
      },
      "writtenOn": "2018-09-05T03:55:21Z",
      "side": 1,
      "message": "One more question: I think I\u0027ve managed to teach CMake that the various header files are generated using the proper Go invocation (see patchset #6), but I\u0027m not sure how to specify that our targets depend on those header files. Any ideas here?",
      "parentUuid": "8e5a39af_4c4bd400",
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a221d60_6829a71b",
        "filename": "BUILDING.md",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-08-29T19:58:17Z",
      "side": 1,
      "message": "I think you just mean \"boringssl_prefix_symbols.h\", right?",
      "range": {
        "startLine": 150,
        "startChar": 11,
        "endLine": 150,
        "endChar": 18
      },
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80186c37_8410538d",
        "filename": "BUILDING.md",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 8959
      },
      "writtenOn": "2018-08-29T22:50:01Z",
      "side": 1,
      "message": "Good catch; fixed.",
      "parentUuid": "1a221d60_6829a71b",
      "range": {
        "startLine": 150,
        "startChar": 11,
        "endLine": 150,
        "endChar": 18
      },
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e6f1d647_2df9d4a7",
        "filename": "crypto/perlasm/x86_64-xlate.pl",
        "patchSetId": 2
      },
      "lineNbr": 1131,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-08-29T19:58:17Z",
      "side": 1,
      "message": "I believe this should work for Yasm/NASM:\n\n%ifdef BORINGSSL_PREFIX\n%include \"boringssl_prefix_symbols_nasm.inc\"\n%endif",
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4ecae29_8e8495c1",
        "filename": "crypto/perlasm/x86_64-xlate.pl",
        "patchSetId": 2
      },
      "lineNbr": 1131,
      "author": {
        "id": 8959
      },
      "writtenOn": "2018-08-29T22:50:01Z",
      "side": 1,
      "message": "OK, done. I\u0027ve also updated BUILDING.md to reference this. I\u0027m not familiar with NASM, so feel free to correct my wording in BUILDING.md.",
      "parentUuid": "e6f1d647_2df9d4a7",
      "revId": "e49159635fb62e6be91ed7c84089da58ededc263",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    }
  ]
}