{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6ffa1255_2e5fcc0f",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-19T16:20:18Z",
      "side": 1,
      "message": "BoringSSL already automatically cleanses anything allocated by `OPENSSL_malloc`. Is that sufficient for you?\n\nIf not, is there any reason this can\u0027t be in your library code?",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44c6b06a_a8a6bfca",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16241
      },
      "writtenOn": "2023-05-20T03:44:00Z",
      "side": 1,
      "message": "This is used for the objects that are allocated on the stack, so the use case is a little different between to OPENSSL_malloc.",
      "parentUuid": "6ffa1255_2e5fcc0f",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e5b97e9_5036b97f",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-22T17:07:54Z",
      "side": 1,
      "message": "Ah. We generally do not cleanse things on the stack. That really cannot be done without compiler support. Registers (which may contain secrets) get spilled to the stack constantly.\n\nIf you all still want to cleanse things on the stack despite this, it sounds like this should be in your project, and not BoringSSL.",
      "parentUuid": "44c6b06a_a8a6bfca",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b1fbce2_b9d25880",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16246
      },
      "writtenOn": "2023-05-22T22:30:34Z",
      "side": 1,
      "message": "The case we\u0027re trying to handle is something like the following:\n\n```\nstd::array\u003cuint8_t, KEY_LEN\u003e \u003e enc_key;\n// AES operation\n```\n\nIs the canonical way to do this in BoringSSL to use `OPENSSL_malloc`?\n\n```\nuint8_t* enc_key \u003d OPENSSL_malloc(KEY_LEN);\n```\n\nOr a `std::allocator` implementation that could be used with `std::vector`, etc? We have [something like this in ChromeOS](https://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/platform2/libbrillo/brillo/secure_blob.h;l\u003d22-26;drc\u003d3a446f27a00fba076a5a42d383ae6134c333ee57).",
      "parentUuid": "2e5b97e9_5036b97f",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4df95c9b_86c3c813",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-23T15:36:35Z",
      "side": 1,
      "message": "In BoringSSL, we just write `uint8_t enc_key[KEY_LEN]` and don\u0027t think about it too hard. :-) (We\u0027re C, so `std::array\u003cuint8_t, KEY_LEN\u003e` in C++ if you prefer.)\n\nThe problem is cleansing things on the stack in C/C++ is hopeless without compiler support. Secrets end up in registers, and those registers are going to get spilled on the stack. And then putting `OPENSSL_cleanse` in places is both more things to keep track of and also inhibits compiler optimizations to keep things out of memory in the first place, or reduce stack space. So our position is not to bother.\n\nIf your project has a different position, that\u0027s fine (though I would caution it is as pointless for you all as it is for us), but then that should go in your project.",
      "parentUuid": "8b1fbce2_b9d25880",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3c51b7a_9d72a3c5",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16171
      },
      "writtenOn": "2023-05-23T15:40:19Z",
      "side": 1,
      "message": "\u003e Secrets end up in registers, and those registers are going to get spilled on the stack\n\nWhy does OpenSSL bother clearing memory allocated by `OPENSSL_malloc`?",
      "parentUuid": "4df95c9b_86c3c813",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1f619da_e993d724",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-23T15:42:51Z",
      "side": 1,
      "message": "That\u0027s the heap, not the stack. But to answer your question, OpenSSL does not automatically cleanse on `OPENSSL_free` like we do. That\u0027s something we did in BoringSSL because we got tired of bifurcating everything between things like `BN_free` vs `BN_clear_free` and likewise up the layers. (They also don\u0027t take the same position we do for the stack.)",
      "parentUuid": "a3c51b7a_9d72a3c5",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6397e65_1913e3cc",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16171
      },
      "writtenOn": "2023-05-23T15:51:21Z",
      "side": 1,
      "message": "\u003e That\u0027s the heap, not the stack.\n\nYeah, I\u0027m well aware. ðŸ˜Š\n\nRegardless of heap or stack, the compiler can copy data into registers (e.g., instead of allocating space for variables on the stack), so I\u0027m not sure I see the difference in how that would affect whether secrets end up in registers  (which are then pushed to the stack during function calls, etc.).\n\n \u003e  That\u0027s something we did in BoringSSL because we got tired of bifurcating everything between things like BN_free vs BN_clear_free and likewise up the layers.\n \n Ok, so the decision in BoringSSL has nothing to do with trying to clear secrets from memory; just keeping the code simpler.",
      "parentUuid": "f1f619da_e993d724",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f770b60_18d41796",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-23T15:59:47Z",
      "side": 1,
      "message": "\u003e Regardless of heap or stack, the compiler can copy data into registers [...]\n\nThe difference is the compiler won\u0027t spill secrets to the stack. So we can coherently aim to clear secrets out of the heap. We do that by making `OPENSSL_free` automatically cleanse, for the stack of simplicity.\n\nHowever, there is no hope in keeping secrets out of the stack without toolchain support, which will certainly not look like explicit calls to `OPENSSL_cleanse`.\n\n\u003e Ok, so the decision in BoringSSL has nothing to do with trying to clear secrets from memory; just keeping the code simpler.\n\nNo, it\u0027s to keep the code simpler while still clearing secrets from the heap. If we just wanted to keep the code simpler, we\u0027d just drop `OPENSSL_cleanse` altogether.\n\nI\u0027ll reiterate the point made several times in this thread: you all proposing to add a new API to BoringSSL here. This API is just a thin wrapper over an API we already provide. There is nothing stopping you all from just doing this in your project, in an openssl_util.h or whatever header.",
      "parentUuid": "c6397e65_1913e3cc",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "222dd356_481970ee",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16171
      },
      "writtenOn": "2023-05-23T18:10:26Z",
      "side": 1,
      "message": "\u003e  There is nothing stopping you all from just doing this in your project, in an openssl_util.h or whatever header.\n\nYeah, at this point I\u0027m just trying to understand the assumptions that boringssl made, so we can decide what makes sense for our project. I understand this CL is not relevant for boringssl to take.\n\n\u003e The difference is the compiler won\u0027t spill secrets to the stack. So we can coherently aim to clear secrets out of the heap. We do that by making OPENSSL_free automatically cleanse, for the stack of simplicity.\n\nIs that because you\u0027re careful to make sure that you don\u0027t do something like this?\n\n```\n{\n ptr \u003d secret_in_heap;\n\n uint32_t secret_val \u003d *secret_in_heap; // oops, maybe on stack\n uint32_t result \u003d secret_val ^ value;\n \n // oops, secret_val maybe pushed on stack\n some_other_function();\n}\n```\n\nInstead, you\u0027re careful that all code that references secrets is done through pointers and rvalues so that it doesn\u0027t get pushed on the stack?\n\ne.g., above would be:\n\n```\n{\n  ptr \u003d secret_in_heap;\n\n  uint32_t result \u003d *secret_in_heap ^ value;\n \n  // *secret_in_heap was rvalue so nothing to push on stack\n  some_other_function();\n}\n```\n\nI\u0027m still trying to reason through whether an rvalue  could be pushed on the stack if there weren\u0027t enough registers available to perform other operations that use it.\n\nOr even a case like this:\n\n```\n{\n  ptr \u003d secret_in_heap;\n\n  // compiler could load secret_in_heap into register, push to stack, \n  // call some_other_function?\n  uint32_t result \u003d *secret_in_heap ^ some_other_function(); \n}\n```",
      "parentUuid": "0f770b60_18d41796",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55590cf1_b49af026",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-23T18:31:42Z",
      "side": 1,
      "message": "I think you may be overthinking it. ðŸ˜Š We *do not try to protect against secrets on the stack*. We assume secrets can make their way on the stack, including secrets that were otherwise stored in the heap, and that\u0027s life. It is impossible to prevent that in C/C++ without toolchain help. It\u0027d be cool if we did have toolchain help, but no one\u0027s done that yet. Until then, we don\u0027t want to waste time calling `OPENSSL_cleanse` on stack buffers when it won\u0027t actually save you from a stack leak anyway. Don\u0027t leak your stack.",
      "parentUuid": "222dd356_481970ee",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9d8966b_4ba4715c",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16171
      },
      "writtenOn": "2023-05-23T22:13:45Z",
      "side": 1,
      "message": "Thanks for the clarification.\n\n\u003e  Until then, we don\u0027t want to waste time calling OPENSSL_cleanse on stack buffers when it won\u0027t actually save you from a stack leak anyway\n\nI think the part that I\u0027m still stuck on is why ever bother calling `OPENSSL_cleanse` at all given that data from the heap could also inadvertently end up on the stack? (That\u0027s why I was trying to work out to what extent that was possible in my last comment.)",
      "parentUuid": "55590cf1_b49af026",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba716425_a3c41e14",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-23T22:23:47Z",
      "side": 1,
      "message": "Ah, I see.\n\nDepends on how your address space leaked I suppose. If you managed to leak your *entire* address space, yeah, you lose. But I think you just lose anyway in that case. Whether or not we manage to zero secrets on release, the secrets are ultimately alive in memory *somewhere*.\n\nBut if you\u0027re worried about a random memory error, whether it can leak the stack or a random chunk of a heap probably depends on the error. They tend to be a bit separated. (Malloc won\u0027t return a stack pointer, and stack allocations won\u0027t give you a heap thing. And usually there\u0027s some guard pages between the two, I think.) So zeroing heap stuff is... at least not obviously useless. ðŸ˜Š And since the compiler won\u0027t spill there, we can actually do it without toolchain involvement, unlike the stack.",
      "parentUuid": "c9d8966b_4ba4715c",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7189820c_cc7265aa",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 268,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-19T16:20:18Z",
      "side": 1,
      "message": "Why isn\u0027t this just a `static_assert`. That seems less complicated than messing around with SFINAE.",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "970a7e98_f9a037b2",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 268,
      "author": {
        "id": 16241
      },
      "writtenOn": "2023-05-20T03:44:00Z",
      "side": 1,
      "message": "hmm, I was thinking that we might want to add specifications for the other types, e.g. std::vector.",
      "parentUuid": "7189820c_cc7265aa",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a803aea_21d6db20",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 268,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-22T17:07:54Z",
      "side": 1,
      "message": "Let\u0027s move this to your library then. If this is something that supports specializations, then we\u0027d be saying that specializing this is part of our public API, and that\u0027s going even further than this CL.",
      "parentUuid": "970a7e98_f9a037b2",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}