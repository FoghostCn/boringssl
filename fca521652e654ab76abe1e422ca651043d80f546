{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6ffa1255_2e5fcc0f",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-19T16:20:18Z",
      "side": 1,
      "message": "BoringSSL already automatically cleanses anything allocated by `OPENSSL_malloc`. Is that sufficient for you?\n\nIf not, is there any reason this can\u0027t be in your library code?",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44c6b06a_a8a6bfca",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16241
      },
      "writtenOn": "2023-05-20T03:44:00Z",
      "side": 1,
      "message": "This is used for the objects that are allocated on the stack, so the use case is a little different between to OPENSSL_malloc.",
      "parentUuid": "6ffa1255_2e5fcc0f",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e5b97e9_5036b97f",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-22T17:07:54Z",
      "side": 1,
      "message": "Ah. We generally do not cleanse things on the stack. That really cannot be done without compiler support. Registers (which may contain secrets) get spilled to the stack constantly.\n\nIf you all still want to cleanse things on the stack despite this, it sounds like this should be in your project, and not BoringSSL.",
      "parentUuid": "44c6b06a_a8a6bfca",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b1fbce2_b9d25880",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16246
      },
      "writtenOn": "2023-05-22T22:30:34Z",
      "side": 1,
      "message": "The case we\u0027re trying to handle is something like the following:\n\n```\nstd::array\u003cuint8_t, KEY_LEN\u003e \u003e enc_key;\n// AES operation\n```\n\nIs the canonical way to do this in BoringSSL to use `OPENSSL_malloc`?\n\n```\nuint8_t* enc_key \u003d OPENSSL_malloc(KEY_LEN);\n```\n\nOr a `std::allocator` implementation that could be used with `std::vector`, etc? We have [something like this in ChromeOS](https://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/platform2/libbrillo/brillo/secure_blob.h;l\u003d22-26;drc\u003d3a446f27a00fba076a5a42d383ae6134c333ee57).",
      "parentUuid": "2e5b97e9_5036b97f",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4df95c9b_86c3c813",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-23T15:36:35Z",
      "side": 1,
      "message": "In BoringSSL, we just write `uint8_t enc_key[KEY_LEN]` and don\u0027t think about it too hard. :-) (We\u0027re C, so `std::array\u003cuint8_t, KEY_LEN\u003e` in C++ if you prefer.)\n\nThe problem is cleansing things on the stack in C/C++ is hopeless without compiler support. Secrets end up in registers, and those registers are going to get spilled on the stack. And then putting `OPENSSL_cleanse` in places is both more things to keep track of and also inhibits compiler optimizations to keep things out of memory in the first place, or reduce stack space. So our position is not to bother.\n\nIf your project has a different position, that\u0027s fine (though I would caution it is as pointless for you all as it is for us), but then that should go in your project.",
      "parentUuid": "8b1fbce2_b9d25880",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3c51b7a_9d72a3c5",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16171
      },
      "writtenOn": "2023-05-23T15:40:19Z",
      "side": 1,
      "message": "\u003e Secrets end up in registers, and those registers are going to get spilled on the stack\n\nWhy does OpenSSL bother clearing memory allocated by `OPENSSL_malloc`?",
      "parentUuid": "4df95c9b_86c3c813",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1f619da_e993d724",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-23T15:42:51Z",
      "side": 1,
      "message": "That\u0027s the heap, not the stack. But to answer your question, OpenSSL does not automatically cleanse on `OPENSSL_free` like we do. That\u0027s something we did in BoringSSL because we got tired of bifurcating everything between things like `BN_free` vs `BN_clear_free` and likewise up the layers. (They also don\u0027t take the same position we do for the stack.)",
      "parentUuid": "a3c51b7a_9d72a3c5",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6397e65_1913e3cc",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 16171
      },
      "writtenOn": "2023-05-23T15:51:21Z",
      "side": 1,
      "message": "\u003e That\u0027s the heap, not the stack.\n\nYeah, I\u0027m well aware. ðŸ˜Š\n\nRegardless of heap or stack, the compiler can copy data into registers (e.g., instead of allocating space for variables on the stack), so I\u0027m not sure I see the difference in how that would affect whether secrets end up in registers  (which are then pushed to the stack during function calls, etc.).\n\n \u003e  That\u0027s something we did in BoringSSL because we got tired of bifurcating everything between things like BN_free vs BN_clear_free and likewise up the layers.\n \n Ok, so the decision in BoringSSL has nothing to do with trying to clear secrets from memory; just keeping the code simpler.",
      "parentUuid": "f1f619da_e993d724",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f770b60_18d41796",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-23T15:59:47Z",
      "side": 1,
      "message": "\u003e Regardless of heap or stack, the compiler can copy data into registers [...]\n\nThe difference is the compiler won\u0027t spill secrets to the stack. So we can coherently aim to clear secrets out of the heap. We do that by making `OPENSSL_free` automatically cleanse, for the stack of simplicity.\n\nHowever, there is no hope in keeping secrets out of the stack without toolchain support, which will certainly not look like explicit calls to `OPENSSL_cleanse`.\n\n\u003e Ok, so the decision in BoringSSL has nothing to do with trying to clear secrets from memory; just keeping the code simpler.\n\nNo, it\u0027s to keep the code simpler while still clearing secrets from the heap. If we just wanted to keep the code simpler, we\u0027d just drop `OPENSSL_cleanse` altogether.\n\nI\u0027ll reiterate the point made several times in this thread: you all proposing to add a new API to BoringSSL here. This API is just a thin wrapper over an API we already provide. There is nothing stopping you all from just doing this in your project, in an openssl_util.h or whatever header.",
      "parentUuid": "c6397e65_1913e3cc",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7189820c_cc7265aa",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 268,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-19T16:20:18Z",
      "side": 1,
      "message": "Why isn\u0027t this just a `static_assert`. That seems less complicated than messing around with SFINAE.",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "970a7e98_f9a037b2",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 268,
      "author": {
        "id": 16241
      },
      "writtenOn": "2023-05-20T03:44:00Z",
      "side": 1,
      "message": "hmm, I was thinking that we might want to add specifications for the other types, e.g. std::vector.",
      "parentUuid": "7189820c_cc7265aa",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a803aea_21d6db20",
        "filename": "include/openssl/mem.h",
        "patchSetId": 6
      },
      "lineNbr": 268,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-05-22T17:07:54Z",
      "side": 1,
      "message": "Let\u0027s move this to your library then. If this is something that supports specializations, then we\u0027d be saying that specializing this is part of our public API, and that\u0027s going even further than this CL.",
      "parentUuid": "970a7e98_f9a037b2",
      "revId": "fca521652e654ab76abe1e422ca651043d80f546",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}