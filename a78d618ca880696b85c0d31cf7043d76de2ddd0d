{
  "comments": [
    {
      "key": {
        "uuid": "c20802ae_e8a8d3ae",
        "filename": "ssl/s3_srvr.c",
        "patchSetId": 4
      },
      "lineNbr": 1651,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-10-01T17:47:05Z",
      "side": 1,
      "message": "Here, let\u0027s move the CBS_init outside the if block and then use s-\u003einit_num instead of n. That\u0027ll appease MSVC about client_key_exchange not being initialized.",
      "revId": "a78d618ca880696b85c0d31cf7043d76de2ddd0d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c20802ae_88b71707",
        "filename": "ssl/s3_srvr.c",
        "patchSetId": 4
      },
      "lineNbr": 1786,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-10-01T17:47:05Z",
      "side": 1,
      "message": "Here, clean is unhappy about decrypt_len may not be initialized. Let\u0027s match this CL: https://boringssl-review.googlesource.com/5765\n\nSo we get rid of state SSL3_ST_SR_KEY_EXCH_D as it\u0027s only entered synchronously anyway. And then we do:\n\nenum ssl_private_key_result_t decrypt_result;\nsize_t decrypt_len;\nif (s-\u003estate \u003d\u003d SSL3_ST_SR_KEY_EXCH_B) {\n  // Large block of code that happens on first run here.\n  decrypt_result \u003d ssl_private_key_decrypt(s, decrypt_buf, \u0026decrypt_len, /* blah blah blah */);\n} else {\n  assert(s-\u003estate \u003d\u003d SSL3_ST_SR_KEY_EXCH_C);\n  decrypt_result \u003d ssl_private_key_decrypt_complete(s, decrypt_buf, \u0026decrypt_len, rsa_size);\n}\n \nswitch (decrypt_result) {\n  case ssl_private_key_success:\n    s-\u003erwstate \u003d SSL_NOTHING;\n    break;\n  case ssl_private_key_failure:\n    s-\u003erwstate \u003d SSL_NOTHING;\n    goto err;\n  case ssl_private_key_retry:\n    s-\u003erwstate \u003d SSL_PRIVATE_KEY_OPERATION;\n    s-\u003estate \u003d SSL3_ST_SR_KEY_EXCH_C;\n    goto err;\n}\n \nif (decrypt_len !\u003d rsa_size) {\n  ....",
      "revId": "a78d618ca880696b85c0d31cf7043d76de2ddd0d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4d31695_a7dbea08",
        "filename": "ssl/ssl_rsa.c",
        "patchSetId": 4
      },
      "lineNbr": 702,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-10-01T17:47:05Z",
      "side": 1,
      "message": "Oh, sorry, I should have been clearer. I meant the other way around. :-) We probably ought to check the key type for EVP_PKEYs before dereferencing as RSA, but just calling the callback for the key_method case is vaguely more consistent, and they already need to internally handle their own preconditions.",
      "revId": "a78d618ca880696b85c0d31cf7043d76de2ddd0d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4d31695_27a9ba5f",
        "filename": "ssl/test/runner/runner.go",
        "patchSetId": 4
      },
      "lineNbr": 2271,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-10-01T17:47:05Z",
      "side": 1,
      "message": "Nit: I\u0027d add a comment since it\u0027s not obvious why only async is going through this path.\n\n  // Test async keys against each key exchange.",
      "revId": "a78d618ca880696b85c0d31cf7043d76de2ddd0d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    }
  ]
}