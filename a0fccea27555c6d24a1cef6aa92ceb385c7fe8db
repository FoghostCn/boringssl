{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d067d8a3_e558185c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "Sorry, I meant to get through more of this today, but the day got away from me. :-/ Flushing some comments to unblock things.",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bec1300f_22ab2ea5",
        "filename": "include/openssl/ssl.h",
        "patchSetId": 14
      },
      "lineNbr": 3582,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "s/must be must be/must be/\n\n(This was probably my fault.)",
      "range": {
        "startLine": 3582,
        "startChar": 53,
        "endLine": 3582,
        "endChar": 69
      },
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c404098d_f3ecb175",
        "filename": "ssl/handshake.cc",
        "patchSetId": 14
      },
      "lineNbr": 171,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "!ec_client_hello_buf_.empty()",
      "range": {
        "startLine": 171,
        "startChar": 6,
        "endLine": 171,
        "endChar": 27
      },
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4ab8a93_ceaf9dce",
        "filename": "ssl/handshake.cc",
        "patchSetId": 14
      },
      "lineNbr": 186,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "80 chars",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed46ac94_c8e4bf4d",
        "filename": "ssl/handshake_server.cc",
        "patchSetId": 14
      },
      "lineNbr": 665,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "This abstraction can\u0027t be called so late in the function. The public API says that it is allowed to return a retry value (although it turns out it never will), yet retrying will behave incorrectly since we\u0027re rerun the logic about. That\u0027s why we always grab the SSLMessage at the very start of the function.\n\nInstead, let\u0027s fix this abstraction to only return success/failure. It\u0027s not actually possible to be retryable here since you\u0027ve already read in the ClientHello. So replace the ssl_hs_read_message return value with something like:\n\n  // The message has already been read, so this cannot fail.\n  OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n  return false;",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49bdb7c2_4a1aa0d3",
        "filename": "ssl/handshake_server.cc",
        "patchSetId": 14
      },
      "lineNbr": 797,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "Same comment as above, every non-OK non-error ssl_hs_wait_t must happen at a retry-safe point and this is not retry-safe.",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d975aab9_d8255266",
        "filename": "ssl/internal.h",
        "patchSetId": 14
      },
      "lineNbr": 1676,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "Let\u0027s match the existing code. I\u0027ve intentionally just left everything on SSL_HANDSHAKE public for now.\n\nThe problem is that SSL_HANDSHAKE has not been thought through w.r.t. C++ visibility yet. At the end of the day, the random functions that take an SSL_HANDSHAKE* should have access to the struct\u0027s internals. If we did this properly, they\u0027d all be methods on SSL_HANDSHAKE, at which point the public/private boundary will be very different. (Although it\u0027s important for the static linker to drop client/server code when unused, so that\u0027ll take some thinking.)\n\nThis ResizeSecrets business is a weird special case because I didn\u0027t want code to accidentally touch the full-sized buffers. But none of that applies to the fields you\u0027re adding.",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd217136_fdfd69c6",
        "filename": "ssl/internal.h",
        "patchSetId": 14
      },
      "lineNbr": 1682,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "Rather than store this alongside, we can both be more obviously memory-safe (Rust forbids this kind of self-pointer) and use less memory by omitting this altogether and instead computing the SSLMessage in your client_hello() accessor below.",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb58e3d2_5a7165ce",
        "filename": "ssl/internal.h",
        "patchSetId": 14
      },
      "lineNbr": 1690,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "This is much more subtle than the documentation suggests because once you call next_message(), even though the buffer is still there, you can\u0027t usefully call this function anymore.\n\n(In fact, there\u0027s probably something to be said for clearing the buffer to save some memory after we\u0027ve called next_message() to advance past the ClientHello.)",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "408b2207_2c379b02",
        "filename": "ssl/internal.h",
        "patchSetId": 14
      },
      "lineNbr": 1692,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "These should be UpperCamelCase per Google C++ style. (Only very simple getters and setters are unix_style(), and these are extremely care from that.) Or match existing code and have some free functions until we\u0027ve sorted out what to do here.",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9dac6873_ebde1900",
        "filename": "ssl/internal.h",
        "patchSetId": 14
      },
      "lineNbr": 1698,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "const",
      "range": {
        "startLine": 1698,
        "startChar": 30,
        "endLine": 1698,
        "endChar": 46
      },
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c2e96ad_85019687",
        "filename": "ssl/tls13_server.cc",
        "patchSetId": 14
      },
      "lineNbr": 620,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-02-17T23:43:15Z",
      "side": 1,
      "message": "Same comment as in handshake_server.cc, this abstraction does not work. Any time you return an ssl_hs_wait_t, you need to be retry-safe, and this is not retry-safe. (Decrypting a second ClientHello is not idempotent. Even if it were, we would not do it at every state machine iteration.)",
      "revId": "a0fccea27555c6d24a1cef6aa92ceb385c7fe8db",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}