{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1a1da40f_8d6e7a33",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5955
      },
      "writtenOn": "2020-10-13T15:05:19Z",
      "side": 1,
      "message": "As a first pass, does this API look reasonable? I\u0027ll add some tests if so.",
      "revId": "eb08a8995f8490e08d07561be52f92b573fcfca0",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23677d1c_3b76c37c",
        "filename": "include/openssl/trust_token.h",
        "patchSetId": 1
      },
      "lineNbr": 254,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-13T19:16:13Z",
      "side": 1,
      "message": "These two bits don\u0027t actually figure into any of the crypto, right? It\u0027s just a random value that the client passes to begin_redemption and then redeem(_raw) blindly passes them out. Would it make sense to instead take those out? Maybe begin_redemption can be removed in favor of just serializing the token, I dunno.\n\nHaving a timestamp split out seems particularly worrisome because, at least in the old API, it went into the signed expiration time. But without any validation on the value, the client can just pick any expiration time it wants. Seems the timestamp should be based on the server time rather than the client.\n\nAlthough, looking at VOPRF, that actually has an Unblind() + Finalize() pair, so it seems the intent *is* to bind some info string to the token. So maybe we want to keep some notion of client data? (How is VORPF intended to handle replay? I assume you don\u0027t replay-protect the VOPRF output because that can change the info string. But I assumed issuedToken is an internal value. Or is the idea that Unblind and Finalize are actually distinct functions with replay protection sandwiched in between?)",
      "range": {
        "startLine": 252,
        "startChar": 17,
        "endLine": 254,
        "endChar": 37
      },
      "revId": "eb08a8995f8490e08d07561be52f92b573fcfca0",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "915de8a1_51772ad1",
        "filename": "include/openssl/trust_token.h",
        "patchSetId": 1
      },
      "lineNbr": 254,
      "author": {
        "id": 5945
      },
      "writtenOn": "2020-10-19T16:31:17Z",
      "side": 1,
      "message": "Well, Unblind happens at the end of issuance, and Finalize happens at the start of redemption. Maybe there\u0027s an argument that we should bind the clientdata against the token to prevent client replays, though not sure how necessary that is.\n\nRemoving timestamp here, do you think we should just punt it from the whole V2 protocol (and for now just manually calculate the timestamp in redeem until we get rid of that consumer?",
      "parentUuid": "23677d1c_3b76c37c",
      "range": {
        "startLine": 252,
        "startChar": 17,
        "endLine": 254,
        "endChar": 37
      },
      "revId": "eb08a8995f8490e08d07561be52f92b573fcfca0",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2a59d57_aeb3af46",
        "filename": "include/openssl/trust_token.h",
        "patchSetId": 1
      },
      "lineNbr": 254,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-22T21:29:30Z",
      "side": 1,
      "message": "\u003e Well, Unblind happens at the end of issuance, and Finalize happens at the start of redemption. Maybe there\u0027s an argument that we should bind the clientdata against the token to prevent client replays, though not sure how necessary that is.\n\nOh, I see. Sorry, I confused myself. Ignore that digression. :-) I clearly haven\u0027t wrapped my head around VOPRF being presented as a cooperatively computed function, rather than a PrivacyPass-like primitive.\n\nJust to make sure I\u0027ve unconfused myself, PrivacyPass looks like:\n\nIssuance:\n- Client calls token, blindToken \u003d Blind(input) and sends blindToken\n- Server calls evaluation \u003d Evaluate(blindToken) and sends evaluation\n- Client calls issuedToken \u003d Unblind(token, blindToken, evaluation)\n\nRedemption:\n- Client calls output \u003d Finalize(input, issuedToken, info) and sends all input, info, output values\n- Server calls VerifyFinalize(input, info, output)\n- On success, server checks for duplicates of input (I assume not output since a client can make lots of outputs by varying info)\n\nIs that right?\n\n\u003e Removing timestamp here, do you think we should just punt it from the whole V2 protocol (and for now just manually calculate the timestamp in redeem until we get rid of that consumer?\n\nSeems reasonable to me, though I don\u0027t really know what you all are using all the fields for. I\u0027m just going by some default preferences:\n\n- If BoringSSL doesn\u0027t know what a field is, it\u0027s probably not worth peeling it out and just tossing it into either a general application-supplied info blob, or, if no binding is needed, \n\n- It\u0027s really weird to have an issuer sign over a timestamp that came from the client, with no issuer validation. That just generally makes me suspicious that something isn\u0027t right.",
      "parentUuid": "915de8a1_51772ad1",
      "range": {
        "startLine": 252,
        "startChar": 17,
        "endLine": 254,
        "endChar": 37
      },
      "revId": "eb08a8995f8490e08d07561be52f92b573fcfca0",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43b84577_c06c5c13",
        "filename": "include/openssl/trust_token.h",
        "patchSetId": 1
      },
      "lineNbr": 260,
      "author": {
        "id": 10016
      },
      "writtenOn": "2020-10-13T18:38:42Z",
      "side": 1,
      "message": "Confusing sentence. Please disambiguate between the two \"callers\".",
      "range": {
        "startLine": 259,
        "startChar": 39,
        "endLine": 260,
        "endChar": 37
      },
      "revId": "eb08a8995f8490e08d07561be52f92b573fcfca0",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0933df1_06f9ea11",
        "filename": "include/openssl/trust_token.h",
        "patchSetId": 1
      },
      "lineNbr": 260,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-13T19:17:36Z",
      "side": 1,
      "message": "I think the second \"caller\" is meant to be \"client\". (When we say \"caller\" in BoringSSL API docs, we mean the caller of the function.)",
      "parentUuid": "43b84577_c06c5c13",
      "range": {
        "startLine": 259,
        "startChar": 39,
        "endLine": 260,
        "endChar": 37
      },
      "revId": "eb08a8995f8490e08d07561be52f92b573fcfca0",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e89c5b23_0306c829",
        "filename": "include/openssl/trust_token.h",
        "patchSetId": 1
      },
      "lineNbr": 260,
      "author": {
        "id": 5945
      },
      "writtenOn": "2020-10-19T16:31:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c0933df1_06f9ea11",
      "range": {
        "startLine": 259,
        "startChar": 39,
        "endLine": 260,
        "endChar": 37
      },
      "revId": "eb08a8995f8490e08d07561be52f92b573fcfca0",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}