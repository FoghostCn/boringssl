{
  "comments": [
    {
      "key": {
        "uuid": "7615fce2_86865f0b",
        "filename": "crypto/mem.c",
        "patchSetId": 14
      },
      "lineNbr": 90,
      "author": {
        "id": 5415
      },
      "writtenOn": "2017-08-31T21:37:45Z",
      "side": 1,
      "message": "I actually meant you could just write:\n\n  *((size_t *)ptr) \u003d size;\n\nAnd likewise for the reads.\n\nAlthough, playing around with godbolt.org, it seems GCC is actually smart enough to realize that the return value of malloc is size_t-aligned and emits the more efficient version. And it doesn\u0027t seem to be able to reason based on the pointer being passed into free(). In the general case, ARMv6 is terrible at memcpy:\nhttps://godbolt.org/g/7oJUsF\n\n(Note how the generated code looks much less terrible once you pass -march\u003darmv7-a. ARMv7-A adds unaligned access.)",
      "revId": "d08617387acceb183b209b5d3c7a564ac81b985c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "997388af_1e3b7365",
        "filename": "crypto/mem.c",
        "patchSetId": 14
      },
      "lineNbr": 96,
      "author": {
        "id": 5415
      },
      "writtenOn": "2017-08-31T21:37:45Z",
      "side": 1,
      "message": "Check for ret \u003d\u003d NULL.\n\nAlternatively, you probably could just do:\n\nstatic void *malloc_impl(size_t size, size_t cleanse_size) {\n  stuff...\n}\n\nvoid *OPENSSL_malloc(size_t size) {\n  return malloc_impl(size, size);\n}\n\nvoid *OPENSSL_malloc_without_zero_on_free(size_t size) {\n  return malloc_impl(size, 0);\n}",
      "revId": "d08617387acceb183b209b5d3c7a564ac81b985c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "456cd17a_b14f0e63",
        "filename": "crypto/mem.c",
        "patchSetId": 14
      },
      "lineNbr": 133,
      "author": {
        "id": 5415
      },
      "writtenOn": "2017-08-31T21:37:45Z",
      "side": 1,
      "message": "Ugh, here\u0027s a nuisance. OPENSSL_realloc and \nOPENSSL_malloc_without_zero_on_free don\u0027t play well together. We could maybe instead steal a the high bit of the size_t[*]?\n\n[*] My read of C is that it actually promises that sizes fit in a signed value, so you don\u0027t get the full range of size_t anyway. Pointer differences are defined and those must fit in ptrdiff_t. And usually half your address space is reserved for the kernel anyway.",
      "revId": "d08617387acceb183b209b5d3c7a564ac81b985c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    }
  ]
}