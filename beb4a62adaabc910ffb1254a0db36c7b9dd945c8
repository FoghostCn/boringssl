{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7f686ac1_af1ca0a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-14T20:15:01Z",
      "side": 1,
      "message": "I agree your math is right, but I\u0027m having a really hard time following your comments.",
      "revId": "beb4a62adaabc910ffb1254a0db36c7b9dd945c8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42a3b720_7311274c",
        "filename": "crypto/fipsmodule/bn/montgomery_inv.c",
        "patchSetId": 6
      },
      "lineNbr": 182,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-14T20:15:01Z",
      "side": 1,
      "message": "I\u0027m not following. We\u0027re doing a square-and-multiply with a base of 2(R), no? Using 2^t only works when t divides lgBigR. It does, in this case, but not for general thresholds.\n\nIn the general case, starting the square-and-multiply loop at a later point isn\u0027t the same as picking a different base because of the multiply steps. Of course, we don\u0027t have any multiply steps in this case, but that\u0027s only true for certain stopping points.\n\nI think this comment is starting from the supposition that the threshold will be the word count, but there\u0027s no inherent reason to believe that\u0027s the correct threshold. It just conveniently works out that way.",
      "range": {
        "startLine": 182,
        "startChar": 73,
        "endLine": 182,
        "endChar": 76
      },
      "revId": "beb4a62adaabc910ffb1254a0db36c7b9dd945c8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fba44f3d_33ba3cac",
        "filename": "crypto/fipsmodule/bn/montgomery_inv.c",
        "patchSetId": 6
      },
      "lineNbr": 182,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-16T05:15:55Z",
      "side": 1,
      "message": "You are right that it doesn\u0027t work for general thresholds. There is no one right way to write this code that works for every threshold AND where we don\u0027t end up with dead code that we can\u0027t test for certain thresholds. I\u0027ve chosen here to get rid of the dead untestable logic over having a general solution.\n\nThere is somewhat of an inherent reason that the threshold is related to the word count. n iterations of the squaring loop are equivalent to 2**n * t doublings. lgBigR \u003d 2**BN_BITS2_LG * width. And like you noted, as the number of limbs grow, the big-O complexity analysis favors doing more doublings.\n\nRegarding the base of the exponentiation: We are trying to compute 2^(width * BN_BITS2). That is equivalent of (2^width)^BN_BITS2. I.e. first we do one exponentiation by doubling, to determine a new base for a second exponentiation by squaring.",
      "parentUuid": "42a3b720_7311274c",
      "range": {
        "startLine": 182,
        "startChar": 73,
        "endLine": 182,
        "endChar": 76
      },
      "revId": "beb4a62adaabc910ffb1254a0db36c7b9dd945c8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95371f67_5f03d686",
        "filename": "crypto/fipsmodule/bn/montgomery_inv.c",
        "patchSetId": 6
      },
      "lineNbr": 207,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-14T20:15:01Z",
      "side": 1,
      "message": "This comment looks wrong. `2*R` is not `2*2^t`. We\u0027re trying to calculate `2^t * R \u003d 2^(t + lgBigR)`.",
      "revId": "beb4a62adaabc910ffb1254a0db36c7b9dd945c8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3ae7f9a_f2abd335",
        "filename": "crypto/fipsmodule/bn/montgomery_inv.c",
        "patchSetId": 6
      },
      "lineNbr": 221,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-14T20:15:01Z",
      "side": 1,
      "message": "This doesn\u0027t look right. We\u0027re not computing `R^R`. I think this can be much more straightforwardly explained:\n\nWe\u0027re trying to compute `R*R \u003d 2^lgBigR * R`. We\u0027re starting from `2^t * R`. Doing `BN_BITS2_LG` Montgomery squares takes us to `2^(lgBigR / BN_BITS2 * BN_BITS2) * R \u003d 2^lgBigR R`.\n\nI think what may be going on here is that you keep flipping back and forth between whether `^` means to exponentiate in the Montgomery domain or not.",
      "revId": "beb4a62adaabc910ffb1254a0db36c7b9dd945c8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39d96544_1d0aa425",
        "filename": "crypto/fipsmodule/bn/montgomery_inv.c",
        "patchSetId": 6
      },
      "lineNbr": 221,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-16T04:34:35Z",
      "side": 1,
      "message": "David, would you prefer me to submit the C equivalent of https://github.com/briansmith/ring/pull/1806? Or, do you prefer me to iterate on what\u0027s here? Or something else?",
      "parentUuid": "b3ae7f9a_f2abd335",
      "revId": "beb4a62adaabc910ffb1254a0db36c7b9dd945c8",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}