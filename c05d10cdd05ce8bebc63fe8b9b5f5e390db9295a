{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7f98684e_8fd803ef",
        "filename": "ssl/test/fuzzer_tags.h",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-05-20T20:48:49Z",
      "side": 1,
      "message": "I don\u0027t entirely understand what to do with this env variable.  I ran the server fuzzer with it enabled, but I see \"Error parsing parameters.\" on stderr pretty frequently -- does that indicate that the transcripts are not compatible?",
      "range": {
        "startLine": 27,
        "startChar": 44,
        "endLine": 27,
        "endChar": 66
      },
      "revId": "c05d10cdd05ce8bebc63fe8b9b5f5e390db9295a",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b05b95b_88cb2b8a",
        "filename": "ssl/test/fuzzer_tags.h",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-05-21T20:41:31Z",
      "side": 1,
      "message": "Oh, I\u0027d forgotten about that. Are you just running the fuzzer with this on (i.e. generating new inputs), or are you running it on recorded transcripts?\n\nIf you\u0027re generating new inputs, that\u0027s expected. The fuzzer will naturally spend a lot of time exploring invalid inputs. The point of this flag is to run it on the record transcripts and tells you whether the handshake succeeded. The reason it\u0027s a flag is that those aren\u0027t errors. Anything it prints out is a perfectly valid behavior for the fuzzer, but we\u0027d like to distinguish between a fuzzer that can never explore a handshake and one that can.\n\nWe\u0027ll still see some failed handshakes on record transcripts (some tests are supposed to fail, and sometimes we expect non-portability), so this requires understanding each case you\u0027re looking at. But the point is to confirm that a transcript from the runner does actually drive the fuzzer to roughly the same place most of the time. And so you should confirm that various successful handshake transcripts go through cleanly.",
      "parentUuid": "7f98684e_8fd803ef",
      "range": {
        "startLine": 27,
        "startChar": 44,
        "endLine": 27,
        "endChar": 66
      },
      "revId": "c05d10cdd05ce8bebc63fe8b9b5f5e390db9295a",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65325ba5_16b75dd3",
        "filename": "ssl/test/fuzzer_tags.h",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 9581
      },
      "writtenOn": "2021-05-24T15:16:57Z",
      "side": 1,
      "message": "I was running the fuzzer with BORINGSSL_FUZZER_DEBUG defined, so generating new inputs.\n\nI\u0027m still a little confused what the workflow is here.  If there\u0027s a set of representative transcripts to run against, could I automate it in refresh_ssl_corpora.sh?  (Actually, just took a stab at that.)",
      "parentUuid": "2b05b95b_88cb2b8a",
      "range": {
        "startLine": 27,
        "startChar": 44,
        "endLine": 27,
        "endChar": 66
      },
      "revId": "c05d10cdd05ce8bebc63fe8b9b5f5e390db9295a",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}