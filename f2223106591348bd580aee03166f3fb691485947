{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d58f8715_0612f1d5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T18:15:56Z",
      "side": 1,
      "message": "Oh, one high-level question: how do we test this? In the long run, I think we need to have something on our CI and CQ that exercise this path. Hopefully we can reuse the toolchain from Chromium and Android. But it looks like this also doesn\u0027t do much standalone, so would we need to test it against some package? Should there be some basic tests in Rust to make sure things mostly work?\n\n(Would you have the cycles to pick up some of that, or is that something we\u0027ll have to do? I don\u0027t know how familiar you are with all the LUCI stuff.)",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f861e8b7_b9841e07",
        "filename": "crypto/err/err.c",
        "patchSetId": 14
      },
      "lineNbr": 642,
      "author": {
        "id": 5005
      },
      "writtenOn": "2021-10-05T18:07:29Z",
      "side": 1,
      "message": "Why?",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f8ebc98_c76d470a",
        "filename": "crypto/err/err.c",
        "patchSetId": 14
      },
      "lineNbr": 642,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-18T16:45:34Z",
      "side": 1,
      "message": "rust-openssl relies on this function existing, but boringssl doesn\u0027t expose it in the headers (and doesn\u0027t maintain the ERR_ convention).  I don\u0027t know the history of these error functions, is there a better way?",
      "parentUuid": "f861e8b7_b9841e07",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cea06ef2_5abeeb93",
        "filename": "crypto/err/err.c",
        "patchSetId": 14
      },
      "lineNbr": 642,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-11-19T18:08:58Z",
      "side": 1,
      "message": "rust-openssl does not appear to rely on this function, since it\u0027s not what\u0027s in OpenSSL. Rather, it has a separate openssl_errors crate which uses:\n\n  void ERR_set_error_data(char *data, int flags)\n\nIt then sometimes passes in an OPENSSL_malloc\u0027d buffer with flags ERR_TXT_STRING|ERR_TXT_MALLOCED and other times passes in a pointer to a \u0027static string with only flags ERR_TXT_STRING.\n\nThat is not something BoringSSL\u0027s version of the error queue supports right now. We dropped most of that machinery in https://boringssl-review.googlesource.com/21004\n\nWe could put it back if needed, or have ERR_set_error_data transparently make a malloc\u0027d copy of i, but external callers adding stuff to the error queue is not common. I would hope Rust projects have richer error systems available and don\u0027t need to muck about with OpenSSL\u0027s rather odd one.\n\nIt looks like the only use of this function is in a separate crate, and basically not used by anything.\nhttps://docs.rs/openssl-errors/0.2.0/openssl_errors/\nhttps://crates.io/crates/openssl-errors/reverse_dependencies\n\nDo we need this crate? Can we just omit openssl_errors to start with?",
      "parentUuid": "8f8ebc98_c76d470a",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52480a5d_fad87ea1",
        "filename": "crypto/err/err.c",
        "patchSetId": 14
      },
      "lineNbr": 642,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-22T21:21:51Z",
      "side": 1,
      "message": "It\u0027s not just openssl-errors, `openssl/src/errors.rs` is what uses ERR_set_error_data for `openssl/ssl/callbacks.rs` which puts errors into (open|boring)ssl during callbacks. It\u0027s not so much being used for external projects as for rust-openssl itself",
      "parentUuid": "cea06ef2_5abeeb93",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad442710_d0544f96",
        "filename": "crypto/err/err.c",
        "patchSetId": 14
      },
      "lineNbr": 642,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-11-30T20:37:39Z",
      "side": 1,
      "message": "It looks like it is actually for external projects. rust-openssl, rather than using Rust\u0027s own error system, exposes the OpenSSL error type as public API for externally-supplied callbacks.\n\nThis is not a good public API, but ah well. It\u0027s easier just to implement this function than fix the Rust ecosystem. :-) https://boringssl-review.googlesource.com/c/boringssl/+/50625 should do so, but correctly.",
      "parentUuid": "52480a5d_fad87ea1",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "494c6f0e_765c2ff1",
        "filename": "crypto/obj/nid.rs",
        "patchSetId": 14
      },
      "lineNbr": 1,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T17:54:04Z",
      "side": 1,
      "message": "I suppose generating this via script works too, but can bindgen really not parse a plain header file with #define integer constants?\n\nI see the call to bindgen and other build bits involve a lot of extra complexity to bypass bindgen\u0027s default behavior. What was wrong with the default behavior?",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "138acbe4_1fb6bdcb",
        "filename": "crypto/obj/nid.rs",
        "patchSetId": 14
      },
      "lineNbr": 1,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-18T16:45:34Z",
      "side": 1,
      "message": "hah, the only reason I did it this way was because you suggested it when we were talking about NIDs :)\n\nI ripped it all out and have it generating from the headers now.",
      "parentUuid": "494c6f0e_765c2ff1",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dc8238a7_07ed5016",
        "filename": "crypto/obj/nid.rs",
        "patchSetId": 14
      },
      "lineNbr": 1,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-11-19T18:08:58Z",
      "side": 1,
      "message": "\u003e hah, the only reason I did it this way was because you suggested it when we were talking about NIDs :)\n\nOh, hah, sorry that was a miscommunication. What I meant was that you should replace the manual NID allocation from an earlier patch set with running the script. (Which you\u0027ve done.) Didn\u0027t have any particular opinion as to how the C #defines made their way to Rust, though using bindgen does seem simplest.",
      "parentUuid": "138acbe4_1fb6bdcb",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16fbcf1c_b748d6ae",
        "filename": "include/openssl/err.h",
        "patchSetId": 14
      },
      "lineNbr": 165,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T17:54:04Z",
      "side": 1,
      "message": "Is there a way to do this automatically? I\u0027d suggest switching them to inline functions, but apparently bindgen doesn\u0027t know how to bind those.\nhttps://github.com/rust-lang/rust-bindgen/issues/1090\n\nThe Python cffi bindings system lets you write down the C type signature of a function-like macro, and then it\u0027ll generate C code based on that. Can we do something similar here? Like maybe integrate a C file into the Rust-specific parts that just define a \n\nint ERR_get_lib_rust(uint32_t packed_err) { return ERR_GET_LIB(packed_err); }\n\nAnd then you can bind that.",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "58ff0bac_e7ae1aaf",
        "filename": "include/openssl/err.h",
        "patchSetId": 14
      },
      "lineNbr": 165,
      "author": {
        "id": 13386
      },
      "writtenOn": "2022-01-04T18:16:23Z",
      "side": 1,
      "message": "It\u0027s not quite as elegant in Rust, but I linked in a C file so that we can avoid duplications.",
      "parentUuid": "16fbcf1c_b748d6ae",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2e35ec2_2b312ae7",
        "filename": "include/openssl/err.h",
        "patchSetId": 14
      },
      "lineNbr": 419,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T17:54:04Z",
      "side": 1,
      "message": "Two blank lines between sections, and documentation.\n\nAlthough this doesn\u0027t even match OpenSSL or rust-openssl, which has a flags parameter. Where did you get this prototype from?",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "031ffc64_9e423fcb",
        "filename": "include/openssl/err.h",
        "patchSetId": 14
      },
      "lineNbr": 419,
      "author": {
        "id": 13386
      },
      "writtenOn": "2022-01-04T18:16:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b2e35ec2_2b312ae7",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8df920c0_1c4cbc62",
        "filename": "rust/README.txt",
        "patchSetId": 14
      },
      "lineNbr": 4,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T17:54:04Z",
      "side": 1,
      "message": "s/boringssl/BoringSSL/g\ns/Boringssl/BoringSSL/g",
      "range": {
        "startLine": 4,
        "startChar": 63,
        "endLine": 4,
        "endChar": 72
      },
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5bca2d71_6659c131",
        "filename": "rust/README.txt",
        "patchSetId": 14
      },
      "lineNbr": 4,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-18T16:45:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8df920c0_1c4cbc62",
      "range": {
        "startLine": 4,
        "startChar": 63,
        "endLine": 4,
        "endChar": 72
      },
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "318efc13_05f59989",
        "filename": "rust/README.txt",
        "patchSetId": 14
      },
      "lineNbr": 7,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T17:54:04Z",
      "side": 1,
      "message": "LLVM",
      "range": {
        "startLine": 7,
        "startChar": 206,
        "endLine": 7,
        "endChar": 210
      },
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "804b6e11_ce20f124",
        "filename": "rust/README.txt",
        "patchSetId": 14
      },
      "lineNbr": 7,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-18T16:45:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "318efc13_05f59989",
      "range": {
        "startLine": 7,
        "startChar": 206,
        "endLine": 7,
        "endChar": 210
      },
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d938314_f4e8fd14",
        "filename": "rust/build.rs",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T17:54:04Z",
      "side": 1,
      "message": "Nit: Most of the various new files here probably need copyright headers.",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a99206d8_e0dfda71",
        "filename": "rust/build.rs",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-18T16:45:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5d938314_f4e8fd14",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef7beb4b_16eb7592",
        "filename": "rust/src/bn.rs",
        "patchSetId": 14
      },
      "lineNbr": 6,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T17:54:04Z",
      "side": 1,
      "message": "Why c_ulonglong and c_uint? bn.h uses uint32_t and uint64_t. They are... hopefully the same, but better to bind the actual types. target_pointer_width is also the wrong condition. We\u0027ve historically had to support architectures (x86_64 NaCl) with 32-bit pointers and 64-bit multipliers.\n\nCan we pick up the real definition from bn.h instead. Is the issue that BN_ULONG is a #define instead of a typedef? We can just switch it to a typedef if that would help...",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95157825_5de55675",
        "filename": "rust/src/bn.rs",
        "patchSetId": 14
      },
      "lineNbr": 6,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-18T16:45:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ef7beb4b_16eb7592",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e09121f6_ade762e1",
        "filename": "rust/src/lib.rs",
        "patchSetId": 14
      },
      "lineNbr": 13,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T18:08:37Z",
      "side": 1,
      "message": "Both of these these should either be exported from the C headers or not exported:\n\nPKCS12_DEFAULT_ITER has a corresponding concept in BoringSSL. We should just export the constant, rather than getting it out of sync.\n\nDTLS1_COOKIE_LENGTH is ABI-sensitive. It is the implicit bound on the DTLS cookie generation callback\u0027s output buffer. That should be defined in BoringSSL, not Rust code. Otherwise, getting it out of sync is an ABI failure.\n\nThat said, we don\u0027t support the DTLS cookie generation callback in the first place, so I\u0027m confused why we need this. If you had to patch out the cookie generation callback, surely you can just as easily patch out the reference to DTLS1_COOKIE_LENGTH. If you didn\u0027t patch it out... how is this building?",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6afa080e_af74f422",
        "filename": "rust/src/lib.rs",
        "patchSetId": 14
      },
      "lineNbr": 13,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-18T16:45:34Z",
      "side": 1,
      "message": "I could indeed just patch out the callback!",
      "parentUuid": "e09121f6_ade762e1",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24796df7_753430f4",
        "filename": "rust/wrapper.h",
        "patchSetId": 14
      },
      "lineNbr": 79,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-10-11T17:54:04Z",
      "side": 1,
      "message": "Why do you need this header? Consumers of the library should not be reaching into internals.",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6263328d_895ee321",
        "filename": "rust/wrapper.h",
        "patchSetId": 14
      },
      "lineNbr": 79,
      "author": {
        "id": 13386
      },
      "writtenOn": "2021-11-18T16:45:34Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "24796df7_753430f4",
      "revId": "f2223106591348bd580aee03166f3fb691485947",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}