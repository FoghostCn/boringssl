{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3b2ccb81_d3927292",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-13T01:39:47Z",
      "side": 1,
      "message": "Hi David, I noticed that you implemented this logic but I didn\u0027t quite understand it. I tried to derive it from first principles and I think I either found a simpler way of implementing the same math, or I am overlooking something.\n\nSee https://boringssl-review.googlesource.com/c/boringssl/+/63905 where I at least determined (at least, as far as I can tell) that crypto_test isn\u0027t testing all the stuff that seems relevant for the more complicated logic that exists today.",
      "revId": "a8aa0de5755b844a737d803730360b4abd0ac46d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb32fc72_b59611f3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-13T04:27:03Z",
      "side": 1,
      "message": "So, there are no first principles for why `mont-\u003eN.width` makes for a good threshold. I wrote something that generically accepts any threshold and played around to find what worked well. It makes sense that it scales roughly linearly, but beyond that, it\u0027s a question of how doubling vs Montgomery squaring compare, so I don\u0027t think it can be principled.\n\nI just benchmarked various thresholds on various CPUs across bittedness, and it happened that `mont-\u003eN.width` worked pretty well. Then I kept the generic code and plugged in `mont-\u003eN.width`.\n\nIt sounds like you\u0027ve found that the arbitrary threshold I picked, based on some benchmarks, happens to also not need the fully generic logic. Other thresholds would need the full value.\n\nThat\u0027s quite convenient, though I\u0027ll definitely need to stare at it a bit to confirm you\u0027re right. :-) It could also be that most bit widths used in cryptography are multiples of large powers of 2, so it doesn\u0027t take that high of a threshold for the remainder to be a power of 2.\n\nAs for what the generic code is doing, it\u0027s pretty straightforward. See the long-comment. :-P\n\nThis loop is just a bog-standard square and multiply. The lshift1 is simply `BN_mod_mul_montgomery(\u0026mont-\u003eRR, \u0026mont-\u003eRR, 2R)`. Just observe that ModMulMont(x, 2R) \u003d ModMul(x, 2) \u003d ModAdd(x, x).\n\n```\n  for (unsigned i \u003d iters - 1; i \u003c iters; i--) {\n    if (!BN_mod_mul_montgomery(\u0026mont-\u003eRR, \u0026mont-\u003eRR, \u0026mont-\u003eRR, mont, ctx)) {\n      return 0;\n    }\n    if ((lgBigR \u0026 (1u \u003c\u003c i)) !\u003d 0 \u0026\u0026\n        !bn_mod_lshift1_consttime(\u0026mont-\u003eRR, \u0026mont-\u003eRR, \u0026mont-\u003eN, ctx)) {\n      return 0;\n    }\n  }\n```\n\nNormally a square and multiply would start at `iters \u003d num_bits(lgBigR)`, `mont-\u003eRR \u003d ToMont(1)`. But the first few steps of the multiplication would be faster done by doubling a bunch. So `iters` is just picking a lower starting point, and then computing the corresponding `mont-\u003eRR`.",
      "parentUuid": "3b2ccb81_d3927292",
      "revId": "a8aa0de5755b844a737d803730360b4abd0ac46d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "247812c6_bbb8df57",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-13T04:41:54Z",
      "side": 1,
      "message": "Hi David, I understand all of that. I actually derived the new implementation I proposed separately and then tried to retrofit it into what you\u0027ve done, after verifying that it happened to be equivalent.\n\nThe main issue with the code as-is is that the bn_mod_lshift1_consttime call in the final exponentiation is never made and is not tested. One thing to understand is that for this final exponentiation, the \"base\" of the exponentiation is actually not 2*R but the result of many doublings. Thus doubling isn\u0027t the same as multiplying by the base any more. If it\u0027s correct to substitute a doubling for a multiplication by the base, then it isn\u0027t obvious why and it deserves some testing and/or other attention.\n\nIf you lower the threshold so that the doubling phase doesn\u0027t do `width` doublings, then the bn_mod_lshift1_consttime of the final exponentiation would get triggered, I think. I didn\u0027t try it to see if it actually works.",
      "parentUuid": "bb32fc72_b59611f3",
      "revId": "a8aa0de5755b844a737d803730360b4abd0ac46d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca69c4b3_7fb6dce6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-11-13T04:50:44Z",
      "side": 1,
      "message": "The bn_mod_lshift1_consttime logic was tested while it was still generic and I was playing with the threshold, so I\u0027m pretty sure it works. After all, the original implementation used a threshold of 0. :-)\n\nIt\u0027s discussed here:\n\n\u003e  // The multiply steps take 2^n R to 2^(n+1) R. It is faster to double\n\u003e  // the value instead.\n\nAnyway, if it\u0027s indeed no longer reachable, agreed removing it makes sense. It\u0027s just late here, and I\u0027m planning to take tomorrow off (recovering from travel), but I\u0027ll stare at your new implementation and probably come up with a new version of the long comment. E.g. that sentence above will no longer be relevant.",
      "parentUuid": "247812c6_bbb8df57",
      "revId": "a8aa0de5755b844a737d803730360b4abd0ac46d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e21ff013_e01c4572",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-13T22:43:22Z",
      "side": 1,
      "message": "The base of the squaring-based exponentiation is 2^n R (n \u003d\u003d `t + (lgBigR - (n_bits - 1))`), right?.\n\nSo for an iteration of the square+multiple loop, we start with 2^n. The first squaring results in (2^n R)^2 \u003d 2^2n R, as your comment in the code notes. If the bit is set, then we would then multiply (2^2n R) * (2^n R) \u003d 2^(2n + n) R, which is equivalent to doubling n/2 times, not doubling 1 time, right? Intuitively, the squaring step can\u0027t do more than twice the work of a multiply step.\n\nAt least, that\u0027s my understanding. It makes sense to me because when I change my own similar code to do a doubling instead of a multiply, it doesn\u0027t pass all my tests. The exception is when n is very small (1) or very large (`width`) or where I get lucky with the particular value of `width`.",
      "parentUuid": "ca69c4b3_7fb6dce6",
      "revId": "a8aa0de5755b844a737d803730360b4abd0ac46d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6d469e55_5c257f84",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5525
      },
      "writtenOn": "2023-11-14T01:03:27Z",
      "side": 1,
      "message": ":sigh: My math isn\u0027t here isn\u0027t right either. The problem is that we are using `n` to mean two different things, when really we need two variables. I believe the math in the comments in the updated https://boringssl-review.googlesource.com/c/boringssl/+/63906 is correct. I also verified experimentally that we actually would need t doublings for a multiplication, not just 1.",
      "parentUuid": "e21ff013_e01c4572",
      "revId": "a8aa0de5755b844a737d803730360b4abd0ac46d",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one maximum vote for label \u0027Code-Review\u0027 is required"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "a8aa0de5755b844a737d803730360b4abd0ac46d",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["is:review-enforced_gerrit"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforcement-satisfied_gerrit"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "a8aa0de5755b844a737d803730360b4abd0ac46d",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}