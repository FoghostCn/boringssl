{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5640eb43_f385d1de",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 16056
      },
      "writtenOn": "2023-08-21T18:17:49Z",
      "side": 1,
      "message": "This still needs a little polish, but there was one main question I wanted to ask how you felt about before paging this out of my brain. When I first started this change I decided to generate both the keys and certificates on the fly. I realized there is no _strong_ need to generate the keys on startup, but it also makes the code somewhat simpler. On my machine (M1 pro macbook) it takes \u003c100ms to generate all the necessary keys, which given the time it takes for the rest of the suite to run seems somewhat insignificant.\n\nAny objection to this?",
      "revId": "b4a18bc91d124b3fd44acf5a5ab72ae8987d34e6",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae5c80a9_d02c8c72",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-08-24T18:42:22Z",
      "side": 1,
      "message": "Haven\u0027t had time to look over the CL yet, but thinking more generally for now.\n\nHaving the keys be part of the runner rather than referenced by path has a certain niceness to it. Whether they\u0027re pre-generated or generated on the fly, having runner responsible for plopping them into a random file is probably a good model. util/run_android_test.go (which needs to be updated) would be made a lot simpler if runner were a self-contained binary. Also some internal infra we have (we\u0027ll take care of updating that).\n\nAlthough, why do the certificates need to be generated on the fly? Is it just notBefore/notAfter and wanting them short-lived enough to pass maximum validity constraints?\n\nRegarding keys, I *think* I\u0027d prefer if the keys were pre-generated, but I think it\u0027s a weak preference. RSA key generation is... not exactly fast. We even run this on Android devices sometimes, and it might take longer there?\n\nSomething I thought about, but I think it\u0027s fine: runner actually integrates with our fuzzing strategy. We record transcripts from all the tests here and then use that to seed our TLS fuzzers. We mostly run the TLS fuzzers in a [funny mode with cryptography disabled](https://boringssl.googlesource.com/boringssl/+/HEAD/FUZZING.md#tls-transcripts), so it doesn\u0027t really matter. We also fuzz with that mode off, but in so far as that mode isn\u0027t hopeless (it probably is...), I can\u0027t think of any cases where randomizing the cert and key won\u0027t break transcripts that aren\u0027t already horribly broken.",
      "parentUuid": "5640eb43_f385d1de",
      "revId": "b4a18bc91d124b3fd44acf5a5ab72ae8987d34e6",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74ca438c_ef853e5a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-08-24T18:42:55Z",
      "side": 1,
      "message": "\u003e Having the keys be part of the runner\n\nSorry, I meant both certs and keys here.",
      "parentUuid": "ae5c80a9_d02c8c72",
      "revId": "b4a18bc91d124b3fd44acf5a5ab72ae8987d34e6",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b514e36a_10c16058",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 16056
      },
      "writtenOn": "2023-08-29T16:11:27Z",
      "side": 1,
      "message": "\u003e util/run_android_test.go (which needs to be updated) would be made a lot simpler if runner were a self-contained binary. Also some internal infra we have (we\u0027ll take care of updating that).\n\nOh I didn\u0027t catch this, will take a look at how it works.\n\n\u003e Although, why do the certificates need to be generated on the fly? Is it just notBefore/notAfter and wanting them short-lived enough to pass maximum validity constraints?\n\nPretty much. To a degree though it also prevents bit rot around how/why certs were generated in a particular fashion, making updates to tests more deterministic. When I was looking through the existing certificates, it was extremely confusing why some certs had certain properties and others didn\u0027t (i.e. the RSA chain certificate seemed unnecessary, had unique properties, and was being used in a handful of places, but it turns out none of those properties were required in order for the tests to pass).\n\n\u003e Regarding keys, I think I\u0027d prefer if the keys were pre-generated, but I think it\u0027s a weak preference. RSA key generation is... not exactly fast. We even run this on Android devices sometimes, and it might take longer there?\n\nI\u0027m not particularly strongly opinionated either way here myself. Pretty much all the same logic can be retained with pre-generated keys, and as you say while RSA key gen is _generally_ fast enough on most machines, it gets slow very quickly on machines with constrained resources. Probably makes sense to just retain the current in-tree keys.\n\n\u003e Something I thought about, but I think it\u0027s fine: runner actually integrates with our fuzzing strategy. We record transcripts from all the tests here and then use that to seed our TLS fuzzers. We mostly run the TLS fuzzers in a funny mode with cryptography disabled, so it doesn\u0027t really matter. We also fuzz with that mode off, but in so far as that mode isn\u0027t hopeless (it probably is...), I can\u0027t think of any cases where randomizing the cert and key won\u0027t break transcripts that aren\u0027t already horribly broken.\n\nHah, interesting. I can\u0027t imagine it\u0027d make things worse, it\u0027ll produce an ever so slightly less diverse corpus in terms of the certificates that appear in transcripts (although I guess technically there will be more diversity in the serial numbers and notBefore/notAfter dates), but I\u0027d be quite surprised if that led to anything interesting.",
      "parentUuid": "74ca438c_ef853e5a",
      "revId": "b4a18bc91d124b3fd44acf5a5ab72ae8987d34e6",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19ac4ed4_6237dccb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-08-30T17:51:21Z",
      "side": 1,
      "message": "Cool. Let\u0027s do pre-generated keys (at least RSA keys; ECDSA keygen is fast) and dynamically generated certificates.\n\nMay as well keep the thing where keys are passed in via temporary files though. I.e. whether it\u0027s pre-generated or dynamically generated is an implementation detail of `runner`, and `runner` no longer needs to find data files relative to itself. If we\u0027re going to teach the system how to deal with temporary files, we may as well get those deployment simplicities everywhere.",
      "parentUuid": "b514e36a_10c16058",
      "revId": "b4a18bc91d124b3fd44acf5a5ab72ae8987d34e6",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa6b2cd4_2ca1ac1e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 16056
      },
      "writtenOn": "2023-10-02T06:24:54Z",
      "side": 1,
      "message": "Sorry for the lapse, kept getting side-tracked by Go things. I think I\u0027ve hit all the major points here.\n\nrunner now still relies on the *\\_key.pem files in the directory, but could reasonably be made a truly bundled binary using the [embed](https://pkg.go.dev/embed) library (or by just putting the keys in the source, the PEM encodings aren\u0027t _that_ big...).",
      "parentUuid": "19ac4ed4_6237dccb",
      "revId": "b4a18bc91d124b3fd44acf5a5ab72ae8987d34e6",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}