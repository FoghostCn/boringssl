{
  "comments": [
    {
      "key": {
        "uuid": "19da90b1_7f347878",
        "filename": "third_party/fiat/curve25519.c",
        "patchSetId": 1
      },
      "lineNbr": 107,
      "author": {
        "id": 8749
      },
      "writtenOn": "2018-01-04T14:36:18Z",
      "side": 1,
      "message": "It is not obvious to me that it is fine to have this intermediate (and the additions) be 32-bit. addcarryx_u25(1,UINT32_MAX,UINT32_MAX) would overflow here, and nothing in fiat-crypto proves that these functions are not called with large inputs. I am guessing that the performance impact of changing a, b, and x to uint64_t on this line is negligible. I also think that we would be able to reason through freeze code and establish that the bad cases are never triggered, but perhaps that is not the best use of braincycles.\n\nThe same applies to the next three functions as well.",
      "revId": "af4a88db4456a5c94ab7fc74647eb4d0c076bf4c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac420d61_15a7587a",
        "filename": "third_party/fiat/curve25519.c",
        "patchSetId": 1
      },
      "lineNbr": 107,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-01-04T16:37:55Z",
      "side": 1,
      "message": "Oh, are the inputs here not bounded by u25? Hrmf. I\u0027d assumed that they were analogous to addcarryx_u32 but with 25-bit numbers. (Where can I find how the operations are defined?)",
      "parentUuid": "19da90b1_7f347878",
      "revId": "af4a88db4456a5c94ab7fc74647eb4d0c076bf4c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c633da1_9475c940",
        "filename": "third_party/fiat/curve25519.c",
        "patchSetId": 1
      },
      "lineNbr": 107,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-01-04T17:11:03Z",
      "side": 1,
      "message": "Oh, ugh, I see. Even the first call is out of bounds because of that 1.125 factor...\n\nAt what point in the process do the bounds get applied? How can I find out the actual definition of this intrinsic?",
      "parentUuid": "ac420d61_15a7587a",
      "revId": "af4a88db4456a5c94ab7fc74647eb4d0c076bf4c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06367f5c_72a2ba55",
        "filename": "third_party/fiat/curve25519.c",
        "patchSetId": 1
      },
      "lineNbr": 107,
      "author": {
        "id": 8749
      },
      "writtenOn": "2018-01-04T19:00:11Z",
      "side": 1,
      "message": "The bounds in https://github.com/mit-plv/fiat-crypto/blob/8d465a7de3c0af6be9bc1f998cbeb43f6f4da7fe/src/Specific/solinas32_2e255m19_10limbs/freeze.v talk about the input and output of `freeze`. The bounds on the input obviously imply something about the bounds on intermediate values inside the function, but the specification in that file says nothing about that.\n\nWe can see from the generated code that the word size selection optimization picked uint32_t for `a` and `b` at call of the \"intrinsics\". This was done by propagating bounds through immediate values and then rounding up to next available word size. The pre-rounding bounds for intermediates are not printed anywhere as far as I know. If we had these, it would probably be clear that uint32_t for the sum is enough. However, based on the fact that inputs of addcarryx_u25 are uint32_t, we know that uint64_t for the immediate is enough.\n\nThe definition of addcarry and subborrow in fiat-crypto source code uses mathematical integers and is thus oblivious to boundedness issues. https://github.com/mit-plv/fiat-crypto/blob/9d16ae4ecb6f24ae7eefabd056902b00bf2fe001/src/Util/ZUtil/Definitions.v#L13",
      "parentUuid": "1c633da1_9475c940",
      "revId": "af4a88db4456a5c94ab7fc74647eb4d0c076bf4c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d924a2ed_2565a9b9",
        "filename": "third_party/fiat/curve25519.c",
        "patchSetId": 1
      },
      "lineNbr": 107,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-01-04T21:10:04Z",
      "side": 1,
      "message": "Andres and I chatted out-of-band, resulting in this ticket: https://github.com/mit-plv/fiat-crypto/issues/288",
      "parentUuid": "06367f5c_72a2ba55",
      "revId": "af4a88db4456a5c94ab7fc74647eb4d0c076bf4c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cbc94ac_7eac0d40",
        "filename": "third_party/fiat/curve25519.c",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 5415
      },
      "writtenOn": "2018-01-04T21:38:20Z",
      "side": 1,
      "message": "Notes before I forget:\n\n- If Jason finishes the Fiat bug above by the time I\u0027m not supposed to be writing my talk (I\u0027m too distractable...), use this version, but add an \u00261 after x \u003e\u003e 25 and x \u003e\u003e 26. They\u0027re not necessary, but Fiat hasn\u0027t proved to us that addition doesn\u0027t wraparound.\n\n- If not, switch these to the more conservative 8-bit versions with uint64_t intermediates, along with tidying the p256.c intrinsic. Link to the Fiat bug so it can be switched back afterwards.",
      "revId": "af4a88db4456a5c94ab7fc74647eb4d0c076bf4c",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    }
  ]
}