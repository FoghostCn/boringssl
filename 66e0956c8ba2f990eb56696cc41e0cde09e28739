{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "95e5212d_c3c47a5d",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 43,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Confirmed `(3303 * 128) % 3329` is 1",
      "range": {
        "startLine": 43,
        "startChar": 39,
        "endLine": 43,
        "endChar": 43
      },
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "47aed27c_636f246c",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 116,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Checked all the tables match the comment.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c665da14_e1a39d24",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 119,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Optional: In BIGNUM, I\u0027ve been calling this operation `reduce_once`.",
      "range": {
        "startLine": 119,
        "startChar": 3,
        "endLine": 119,
        "endChar": 16
      },
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "25fa516c_3267752d",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 128,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Hopefully we don\u0027t need to add one later! :-) I think the main risk is that Clang likes to turn runs of CMOVs into branches, but since this is just one value, we\u0027re *probably* safe. It\u0027s mostly table lookups that cause problems.\n\nAnd yeah a value barrier would inhibit the CSEL/CMOV so makes sense that it\u0027d be slower.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b8d8471_0b0dabbe",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 131,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Nit: Maybe add \"x must be at most kPrime + 2 * kPrime * kPrime\", though I suppose it\u0027s in the assert right below.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c1666d0_35ede304",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 133,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Exhaustively tested all inputs up to this to confirm it works. :-)",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "79bdbe5c_db958393",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 153,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "I guess Clang has a hard time learning that `k` is bounded with the `k +\u003d 2 * offset` bit and the loop.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab17eac7_4290c2e7",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 167,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Wrapped my head around the structure of the loop at least, but I\u0027ve no idea how NTTs work. :-)",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6c3ddc2_4855595e",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 238,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Our Barrett reduction still lets us reduce the sum of two products, so I think we can make this *slightly* tighter:\n\n```\n    uint32_t real_real \u003d lhs-\u003ec[2 * i] * rhs-\u003ec[2 * i];\n    uint32_t img_img \u003d rhs-\u003ec[2 * i + 1] * lhs-\u003ec[2 * i + 1];\n    uint32_t real_img \u003d lhs-\u003ec[2 * i] * rhs-\u003ec[2 * i + 1];\n    uint32_t img_real \u003d lhs-\u003ec[2 * i + 1] * rhs-\u003ec[2 * i];\n    out-\u003ec[2 * i] \u003d\n        reduce(real_real + (uint32_t)reduce(img_img) * kModRoots[i]);\n    out-\u003ec[2 * i + 1] \u003d reduce(img_real + real_img);\n```\n\nNot a huge difference, but seems to be +2.5% for generate + decap on my machine. I guess to get a larger Barrett reduction, we\u0027d need to go into u128s, which is a little annoying.\n\n(As an upper bound, if I just write `% kPrime` and make the compiler figure it out, it\u0027s faster but only +0.4% on top of the version above.)",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29ed326d_e3df741e",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 238,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-19T18:30:26Z",
      "side": 1,
      "message": "Update: see comment on `kyber_parse_public_key_no_hash` and `KYBER_parse_private_key`.",
      "parentUuid": "a6c3ddc2_4855595e",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5bb9fb35_e0df3021",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 307,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Between this 128 and the callers, it seems we\u0027re effectively hard-coding `eta` being 2 anyway. Is there even a point in pretending it might be 3? :-)\n\nI.e. we could just call call the functions `scalar_centered_binomial_distribution_2` and `vector_generate_secret_2` and, if we ever need Kyber512, we can add the 3 version. Given that optimizing this function made such a bit difference below, I kinda suspect we\u0027d want to specialize it anyway.",
      "range": {
        "startLine": 307,
        "startChar": 72,
        "endLine": 307,
        "endChar": 75
      },
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77709bc1_6f629924",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 320,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "This is really `value +\u003d select(mask, 0, 1)` and `value +\u003d select(mask, 0, p-1)`, which in turn can be `value +\u003d (mask \u0026 1)` and `value +\u003d (mask \u0026 (p-1))`. The compiler can\u0027t do that on its own because there\u0027s a value barrier inside the select, so it doesn\u0027t know half the bitmasks are removed.\n\nIf I do that but retain the value barrier, it\u0027s a +5% win. If I instead also remove the value barrier, it\u0027s +10%. There\u0027s a bit of risk of compiler mishap, but the compiler\u0027s not doing multiple rounds of it, so hopefully fine?\n\nBut we can actually go further. We don\u0027t need the is_zero_w business because we\u0027re just extracting single bits. Also `eta` is 2 (or 3), so actually we only need to add one copy of p, at which point we don\u0027t need our multiplication-based reduction.\n\nThis gives a +18% boost on my machine.\n\n```\nstatic void scalar_centered_binomial_distribution(scalar *out, int eta,\n                                                  const uint8_t entropy[128]) {\n  assert(eta \u003c\u003d kPrime);  // |value| cannot underflow.\n  for (int i \u003d 0; i \u003c DEGREE; i++) {\n    uint16_t value \u003d kPrime;\n    for (int j \u003d 0; j \u003c eta; j++) {\n      int plus_index \u003d 2 * i * eta + j;\n      int minus_index \u003d (2 * i + 1) * eta + j;\n      uint16_t plus_bit \u003d (entropy[plus_index / 8] \u003e\u003e (plus_index % 8)) \u0026 1;\n      uint16_t minus_bit \u003d (entropy[minus_index / 8] \u003e\u003e (minus_index % 8)) \u0026 1;\n      value \u003d value + plus_bit - minus_bit;\n    }\n    out-\u003ec[i] \u003d reduce_simple(value);\n  }\n}\n```\n\nAnd then if we specialize to eta \u003d\u003d 2, it\u0027s a +20.7% boost instead:\n\n```\nstatic void scalar_centered_binomial_distribution(scalar *out, int eta,\n                                                  const uint8_t entropy[128]) {\n  assert(eta \u003d\u003d 2);\n  for (int i \u003d 0; i \u003c DEGREE; i +\u003d 2) {\n    uint8_t byte \u003d entropy[i / 2];\n\n    uint16_t value \u003d kPrime;\n    value +\u003d (byte \u0026 1) + ((byte \u003e\u003e 1) \u0026 1);\n    value -\u003d ((byte \u003e\u003e 2) \u0026 1) + ((byte \u003e\u003e 3) \u0026 1);\n    out-\u003ec[i] \u003d reduce_simple(value);\n\n    byte \u003e\u003e\u003d 4;\n    value \u003d kPrime;\n    value +\u003d (byte \u0026 1) + ((byte \u003e\u003e 1) \u0026 1);\n    value -\u003d ((byte \u003e\u003e 2) \u0026 1) + ((byte \u003e\u003e 3) \u0026 1);\n    out-\u003ec[i + 1] \u003d reduce_simple(value);\n  }\n}\n```\n\nLooks like part of what\u0027s going on is Clang can vectorize this pretty easily.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e018f8bd_fc0749a0",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 398,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Since we know the output length here, may as well write `uint8_t out[32]` to get what little compiler warnings we can hope for here. :-)",
      "range": {
        "startLine": 398,
        "startChar": 36,
        "endLine": 398,
        "endChar": 40
      },
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d52c68ed_a50488fb",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 452,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "`const uint8_t in[32]` for a tiny bit of checking.",
      "range": {
        "startLine": 452,
        "startChar": 55,
        "endLine": 452,
        "endChar": 57
      },
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0673edb5_5b997a12",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 469,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-18T01:07:23Z",
      "side": 1,
      "message": "Note to self: this is how far through the file I got.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e4c3fb9_a75761d4",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 485,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-19T18:30:26Z",
      "side": 1,
      "message": "It does make us multiply twice, though by a constant. We can also do this with just two conditional increments:\n\n```\nstatic uint16_t compress(uint16_t x, int bits) {\n  uint32_t product \u003d (uint32_t)x \u003c\u003c bits;\n  uint32_t quotient \u003d ((uint64_t)product * kBarrettMultiplier) \u003e\u003e kBarrettShift;\n  uint32_t remainder \u003d product - quotient * kPrime;\n\n  // Adjust the quotient to round correctly:\n  //   0 \u003c\u003d remainder \u003c\u003d kHalfPrime round to 0\n  //   kHalfPrime \u003c remainder \u003c\u003d kPrime + kHalfPrime round to 1\n  //   kPrime + kHalfPrime \u003c remainder \u003c 2 * kPrime round to 2\n  assert(remainder \u003c 2u * kPrime);\n  quotient +\u003d 1 \u0026 constant_time_lt_w(kHalfPrime, remainder);\n  quotient +\u003d 1 \u0026 constant_time_lt_w(kPrime + kHalfPrime, remainder);\n  return quotient \u0026 ((1 \u003c\u003c bits) - 1);\n}\n```\n\nLooks like that\u0027s worth a +4% boost. It does remove some value barriers, but compilers seem to behave here:\nhttps://godbolt.org/z/qxzzqjMaf",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6167fe10_d2cb456d",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 629,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-19T18:30:26Z",
      "side": 1,
      "message": "The tension between strict aliasing, wanting to keep internals private, but also wanting types to be stack-allocatable, is a mess. Not sure how best to deal with this, but I suppose we\u0027ve got patterns like this in a few places already. :-(",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6151687_104cd890",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 653,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-19T18:30:26Z",
      "side": 1,
      "message": "`scalar_centered_binomial_distribution` is only ever called on the output of PRF and, due to the `eta` \u003d 2 or 3 business, every time it\u0027s called we have to calculate `2 * eta * DEGREE / 8`, assert it\u0027s secretly 128, and then SHAKE-256 into a buffer.\n\nWhat if we just folded the PRF call into `scalar_centered_binomial_distribution` and made it:\n\n```\nvoid scalar_centered_binomial_distribution_prf(\n    scalar *out, int eta, const uint8_t input[33])\n```\n\nAlthough not written that way in the spec, the PRF call depends on eta to know how much output it needs, so a combined operation is probably more natural. That also means, if we ever need Kyber-512, we can specialize for eta \u003d\u003d 2 or eta \u003d\u003d 3 inside the function if that ends up being as efficient. (Though I suspect we want to also specialize `vector_generate_secret` to eta so it can be vectorized.)",
      "range": {
        "startLine": 653,
        "startChar": 2,
        "endLine": 653,
        "endChar": 39
      },
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51d3c30b_318a2651",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 682,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-19T18:30:26Z",
      "side": 1,
      "message": "Note to self: still need to look at this point onwards.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06d29a5c_9a9487b1",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 682,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-20T02:23:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "51d3c30b_318a2651",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8c627d8_9a29bdf7",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 748,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-20T02:23:25Z",
      "side": 1,
      "message": "This can be `CRYPTO_memcmp`. Maybe with `constant_time_eq_int` because it technically returns an `int` even though it\u0027s actually the same thing. :-)",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16685e5d_4750831f",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 750,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-20T02:23:25Z",
      "side": 1,
      "message": "Super nitpicky nitpick: Not sure this variable is pulling its weight when we could just write `priv-\u003efo_failure_secret` below. :-)",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6bb8b77_a088f042",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 775,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-19T18:30:26Z",
      "side": 1,
      "message": "This only ensures are coefficients \u003c 2^12 \u003d 4096, so they might not be *quite* fully reduced. Will this break the rest of the calculation? Should we reject this / test that things still work correctly / call reduce_simple on everything?\n\nMy read from the spec is that we\u0027re supposed to tolerate this, because Decode_l is defined to infallibly return something in R_q, which implies:\n\na) We can\u0027t reject any inputs\nb) We can\u0027t just compute the wrong answer on grounds the key is invalid because 0 and 3392 are the same object in R_q.\n\nBut perhaps this should be feedback that the spec should either call this out or reject this case.\n\nIn particular, I think it\u0027s fine for `pub-\u003et` in the current state of the patch set, because that\u0027s only passed to `scalar_inner_product`. But, with the `scalar_mult` I suggested above, I don\u0027t think it works.\n\n`reduce(img_real + real_img)` can be as high as 4095 * 3391 * 2 \u003d 27772290, and that Barrett reduction stops working at 23419515. But this is perhaps a bit fragile (e.g. if we pick up other impls) and maybe we should just reduce on parse to meet the stated preconditions.\n\nI can also confirm that if I bump the input bytes, I hit the assert in the new `scalar_mult`, but don\u0027t hit it in tests, so we don\u0027t seem to include any test coverage for this.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33376123_13cc0c33",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 775,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-19T18:39:00Z",
      "side": 1,
      "message": "\u003e b) We can\u0027t just compute the wrong answer on grounds the key is invalid because 0 and 3392 are the same object in R_q.\n\ns/3392/3329/\n\nInterestingly, the H(pk) step means it\u0027s not the same key in Kyber.CCAKEM, though I think it\u0027s the same key in Kyber.CPAPKE? And, in the private key bit below, I believe the two encodings are the same key.",
      "parentUuid": "b6bb8b77_a088f042",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11ffe9c3_3da9f075",
        "filename": "crypto/kyber/kyber.c",
        "patchSetId": 19
      },
      "lineNbr": 824,
      "author": {
        "id": 5415
      },
      "writtenOn": "2023-03-19T18:30:26Z",
      "side": 1,
      "message": "Ditto about unreduced coefficients. Looks like this is only passed to `scalar_inner_product`, so same story with the `scalar_mult`s.",
      "revId": "66e0956c8ba2f990eb56696cc41e0cde09e28739",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}