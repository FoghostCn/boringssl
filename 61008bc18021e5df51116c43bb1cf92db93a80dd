{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ff0155b4_20de33f8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-05T21:22:44Z",
      "side": 1,
      "message": "Thanks for the contribution. I\u0027ve left some comments on the change itself below, but I also have some higher-level questions. New assembly platforms are expensive to support, and we typically do not accept things we cannot test, so we\u0027ll need to work out the testing story.\n\n- What toolchains do you intend this code to be used with, and what have you tested this on? Which assembler in particular? (Clang\u0027s assembler? The Microsoft one?)\n\n- I noticed you submitted some changes to generate_build_files.py. Is the intention to enable this assembly in Chromium? Have you run the tests with both the standalone CMake build as well as Chromium\u0027s? Note that Chromium typically builds with LLVM, though I don\u0027t know off-hand which assembler it uses on Windows/ARM64.\n\n- How are you envisioning ongoing support for this platform to work? We do not currently have continuous testing on Windows/ARM64.\n\nAnd some questions specific to Windows/ARM64:\n\n- My understanding is that the Windows/ARM64 ABI is similar to AAPCS64. Have you confirmed there aren\u0027t any deviations? If Windows has any odd requirements, they should be tested (see crypto/test/abi_test.h).\n\n- Windows ABIs tend to have unwind requirements for SEH. I haven\u0027t looked closely at the ARM64 variant. What\u0027s the plan for meeting those requirements for the assembly? (I believe all our ARM64 assembly sets up a frame pointer, per iOS64\u0027s requirements, so hopefully the Windows/ARM64 story can use that property.)",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "578fae29_1e2d4905",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 10876
      },
      "writtenOn": "2020-10-06T17:55:27Z",
      "side": 1,
      "message": "Cool, I\u0027ll answer what I can:\n\n\u003e * What toolchains do you intend this code to be used with, and what have you tested this on? Which assembler in particular? (Clang\u0027s assembler? The Microsoft one?)\n\u003e * I noticed you submitted some changes to generate_build_files.py. Is the intention to enable this assembly in Chromium? Have you run the tests with both the standalone CMake build as well as Chromium\u0027s? Note that Chromium typically builds with LLVM, though I don\u0027t know off-hand which assembler it uses on Windows/ARM64.\n\nWe\u0027re targeting this at Chromium-based things (Edge, Electron etc) on AArch64 Windows, so LLVM and its assembler is the only toolchain we\u0027re thinking about at the moment. We\u0027ve tested all the unit tests that end up Chromium with this change (they all pass). CMake: we\u0027re still looking into the best options for cross-compilation and deciding whether that should be supported (it\u0027s not a normal situation for Windows - you can build the non-assembly version OK on the device itself however). We will try to address this in subsequent patchsets.\n\n\u003e * How are you envisioning ongoing support for this platform to work? We do not currently have continuous testing on Windows/ARM64.\n\nThere\u0027s currently a chromium.fyi bot to check that the compilation\u0027s working [1]. We monitor this bot and we also test the Chromium build on real hardware inside Arm (typically 3-4 times a day). Microsoft also test it on hardware as part of their development for Edge, they do often investigate and fix issues that crop up (e.g. [2]). We haven\u0027t had an update recently from Google about their test strategy on this platform. \n\n\u003e And some questions specific to Windows/ARM64:\n\u003e * My understanding is that the Windows/ARM64 ABI is similar to AAPCS64. Have you confirmed there aren\u0027t any deviations? If Windows has any odd requirements, they should be tested (see crypto/test/abi_test.h).\n\nWindows mostly follows the AAPCS64 with regards to argument passing and return values, it differs in some ways (e.g. it returns x8 to the caller in some cases[3]) but we don\u0027t think these are any cases in BoringSSL that are affected by these ABI differences at this time.\n\n\u003e * Windows ABIs tend to have unwind requirements for SEH. I haven\u0027t looked closely at the ARM64 variant. What\u0027s the plan for meeting those requirements for the assembly? (I believe all our ARM64 assembly sets up a frame pointer, per iOS64\u0027s requirements, so hopefully the Windows/ARM64 story can use that property.)\n\nAArch64 does require .pdata annotations for SEH to work correctly if ASM modifies the stack pointer (documented at [4]). We haven\u0027t implemented this yet. AArch64 on Windows does mandate a frame pointer (which makes things easier), but what will currently happen is that the post mortem dump will reveal the program counter in a BoringSSL ASM routine and the register context (which should usually be enough to diagnose the problem), but Windows itself (e.g. through it\u0027s crash dumps etc) won\u0027t report a precise stack trace (something like breakpad or a connected Visual Studio debugger may give more info though). We will implement full SEH support if there\u0027s a reasonable chance that the optimizations might get merged - we\u0027d really like this to happen (since the performance benefit can be \u003e30x). \n\n[1] https://ci.chromium.org/p/chromium/builders/ci/win32-arm64-rel\n[2] https://source.chromium.org/chromium/chromium/src/+/d5b820e21463e127cfac509d7bfdd27bb894b1ca\n[3] https://docs.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view\u003dvs-2019#return-values\n[4] https://docs.microsoft.com/en-us/cpp/build/arm64-exception-handling?view\u003dvs-2019",
      "parentUuid": "ff0155b4_20de33f8",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00c0a25c_23eb5512",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-13T17:57:00Z",
      "side": 1,
      "message": "(Just to circle back here real quick, I\u0027ve ordered a machine so I can at least test this manually. It should arrive this week.)",
      "parentUuid": "578fae29_1e2d4905",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a7e11b68_776e0c2e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-01-08T23:15:12Z",
      "side": 1,
      "message": "(Resolving this thread.)",
      "parentUuid": "00c0a25c_23eb5512",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34b3bac8_2948988f",
        "filename": "crypto/cpu-aarch64-win.c",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-05T21:22:44Z",
      "side": 1,
      "message": "There should be a space after the \u0027if\u0027 here. (Please see STYLE.md and the Google C++ style which it cites.)",
      "range": {
        "startLine": 29,
        "startChar": 4,
        "endLine": 29,
        "endChar": 5
      },
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d633567_4a3832c2",
        "filename": "crypto/cpu-aarch64-win.c",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 10871
      },
      "writtenOn": "2020-10-14T08:07:12Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "34b3bac8_2948988f",
      "range": {
        "startLine": 29,
        "startChar": 4,
        "endLine": 29,
        "endChar": 5
      },
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "391822a7_4855b3de",
        "filename": "crypto/cpu-aarch64-win.c",
        "patchSetId": 1
      },
      "lineNbr": 38,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-05T21:22:44Z",
      "side": 1,
      "message": "This is missing a newline at the end of the file.",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "48e5865d_c0d47f93",
        "filename": "crypto/cpu-aarch64-win.c",
        "patchSetId": 1
      },
      "lineNbr": 38,
      "author": {
        "id": 10871
      },
      "writtenOn": "2020-10-14T08:07:12Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "391822a7_4855b3de",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ddc4a99_50104b9b",
        "filename": "crypto/fipsmodule/bn/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-05T21:22:44Z",
      "side": 1,
      "message": "What\u0027s going on here? I would expect clang-cl to handle GCC-style asm just fine, and I would expect MSVC for ARM64 to not define __GNUC__ or __clang__.",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a59edb01_8cace524",
        "filename": "crypto/fipsmodule/bn/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 10871
      },
      "writtenOn": "2020-10-14T08:07:12Z",
      "side": 1,
      "message": "This is due to a clang-cl issue (https://crbug.com/787617) - the assembly function is generated for x86 and x64 so they are not affected, but does not exist in the arm assembly. As we are using clang-cl, __clang__ is defined.",
      "parentUuid": "9ddc4a99_50104b9b",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4fcdc8a_44485777",
        "filename": "crypto/fipsmodule/bn/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-14T18:14:48Z",
      "side": 1,
      "message": "The clang-cl issue should already be captured by BN_CAN_DIVIDE_ULLONG. clang-cl is, I assume, perfectively capable of GNUC inline asm, so BN_CAN_USE_INLINE_ASM should be defined.\n\nI think I see the issue. It\u0027s that bn_div_words\u0027s compile condition is too tight.\n\nRather than !defined(BN_CAN_DIVIDE_ULLONG) \u0026\u0026 !defined(BN_CAN_USE_INLINE_ASM), it should be:\n\n!defined(BN_CAN_DIVIDE_ULLONG) \u0026\u0026 !(defined(BN_CAN_USE_INLINE_ASM) \u0026\u0026 (defined(OPENSSL_X86) || defined(OPENSSL_X86_64)))\n\nBut this is very tedious, so it may be simpler to emit the function unconditionally, and slap an OPENSSL_UNUSED in front of the function decl to allow for it to be unused.",
      "parentUuid": "a59edb01_8cace524",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "43483425_b77f8d56",
        "filename": "crypto/fipsmodule/bn/internal.h",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-01-08T23:15:12Z",
      "side": 1,
      "message": "(Resolving.)",
      "parentUuid": "c4fcdc8a_44485777",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d451a05_edf079f9",
        "filename": "crypto/perlasm/arm-xlate.pl",
        "patchSetId": 1
      },
      "lineNbr": 88,
      "author": {
        "id": 5415
      },
      "writtenOn": "2020-10-05T21:22:44Z",
      "side": 1,
      "message": "Do you have a pointer to documentation for these directives, as well as MS\u0027s use of the .inst directive below?",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14b680cc_9ace20cf",
        "filename": "crypto/perlasm/arm-xlate.pl",
        "patchSetId": 1
      },
      "lineNbr": 88,
      "author": {
        "id": 10871
      },
      "writtenOn": "2020-10-14T08:07:12Z",
      "side": 1,
      "message": "I based this off of libunwind\u0027s \"assembly.h\", where they do the same thing - I couldn\u0027t find their justification, but it what was needed to make it work.\n\nFor .inst below, I may have made a mistake in understanding the code in clang now I see this pull request: https://reviews.llvm.org/D49935\n\nI assumed that COFF cared about the distinction, but perhaps it doesn\u0027t - will fix.",
      "parentUuid": "4d451a05_edf079f9",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8876aa3f_823772b2",
        "filename": "crypto/perlasm/arm-xlate.pl",
        "patchSetId": 1
      },
      "lineNbr": 88,
      "author": {
        "id": 5415
      },
      "writtenOn": "2021-01-08T23:15:12Z",
      "side": 1,
      "message": "I dug around, and it looks like this wasn\u0027t quite right. These directives are part of the GNU assembler syntax for COFF/PE.\nhttps://sourceware.org/binutils/docs/as/Pseudo-Ops.html\n\n.scl specifies the symbol\u0027s storage class, and .type the symbol\u0027s type.\n\nPer https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-symbol-table, 32 is indeed that Microsoft\u0027s toolchain uses for functions.\n\nStorage class 2 is https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#storage-class, IMAGE_SYM_CLASS_EXTERNAL. Poking around the output, this ends up exporting every symbol with a .type, as opposed to just the ones marked .globl. If I remove it, Clang\u0027s assembler seems to handle it correctly with just .globl, so I think the line was unnecessary.\n\nI\u0027ll go ahead and fix this before landing.",
      "parentUuid": "14b680cc_9ace20cf",
      "revId": "61008bc18021e5df51116c43bb1cf92db93a80dd",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}