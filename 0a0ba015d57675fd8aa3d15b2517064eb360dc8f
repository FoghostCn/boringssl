{
  "comments": [
    {
      "key": {
        "uuid": "c7d48b39_d3594c63",
        "filename": "ssl/s3_srvr.c",
        "patchSetId": 3
      },
      "lineNbr": 1658,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-08-13T22:08:13Z",
      "side": 1,
      "message": "Hrm. Sorry, I should have noticed this earlier. :-/ It\u0027s really not locally obvious here and everywhere else that SSL3_ST_SR_KEY_EXCH_C implies this is false and the alg_k is SSL_kRSA. I bet some compiler is going to go ballistic about unused variables...\n\nPerhaps it\u0027s time now to split out the key exchanges and have the additional states within each key exchange be internal, kinda like the Go implementation. Probably the common could should take care of reading the ClientKeyExchange and ServerKeyExchange messages and if we block on a private key operation, that state is internal to the SSL_KEY_EXCHANGE object.\n\nBut that would mean blocking this work on that refactoring, which is possibly not for the best. I could also imagine deferring that for now and splitting up the ssl3_accept state machine more explicitly---i.e. instead of having a single function per message, perhaps we pull SSL3_ST_SR_KEY_EXCH_C and D into separate functions? I haven\u0027t really explored that one in my head too much. Long-term, I do want to get away from this state machine pre-multiplying everything. Even the A/B states are kind of ridiculous.\n\nI\u0027m not sure. What are your thoughts?",
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a40a365b_129eea58",
        "filename": "ssl/s3_srvr.c",
        "patchSetId": 3
      },
      "lineNbr": 1658,
      "author": {
        "id": 5865
      },
      "writtenOn": "2015-09-02T21:21:11Z",
      "side": 1,
      "message": "I\u0027d prefer to have separate functions for SSL3_ST_SR_KEY_EXCH_C/D states.  Is it ok if I did that in a follow up change?",
      "parentUuid": "c7d48b39_d3594c63",
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c7d48b39_704a8e2f",
        "filename": "ssl/ssl_rsa.c",
        "patchSetId": 3
      },
      "lineNbr": 701,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-08-13T22:08:13Z",
      "side": 1,
      "message": "Optional: I was actually just thinking to do the check after ssl-\u003ecert-\u003ekey_method. It\u0027s more about protecting the invariant that you won\u0027t touch pkey.rsa on a non-RSA EVP_PKEY (line 708 below).\n\nI imagine the decrypt implementation will internally DCHECK or CHECK or whatever, so there\u0027s no need to bounce into the type method. And it\u0027s more consistent with the other wrappers which unconditionally delegate to the method table.\n\nThis is fine too though. Maybe better? Dunno. I don\u0027t really care much either way, so your call.",
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a40a365b_92893a1c",
        "filename": "ssl/ssl_rsa.c",
        "patchSetId": 3
      },
      "lineNbr": 701,
      "author": {
        "id": 5865
      },
      "writtenOn": "2015-09-02T21:21:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c7d48b39_704a8e2f",
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c7d48b39_106a2a8f",
        "filename": "ssl/test/bssl_shim.cc",
        "patchSetId": 3
      },
      "lineNbr": 236,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-08-13T22:08:13Z",
      "side": 1,
      "message": "Hrm, this indentation is strange. :-) Did clang-format do that? Perhaps break right after out_len, so its:\n\n  if (!RSA_decrypt(rsa, out_len,\n                   bssl::vector_data(\u0026test_state-\u003eprivate_key_result),\n                   RSA_size(rsa), in, in_len, RSA_NO_PADDING)) {\n\n(If clang-format did this, ignore me. I solidly approve of algorithms deciding on style and will blindly defer to clang-format in these matters! :-D )",
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a40a365b_727ad6b8",
        "filename": "ssl/test/bssl_shim.cc",
        "patchSetId": 3
      },
      "lineNbr": 236,
      "author": {
        "id": 5865
      },
      "writtenOn": "2015-09-02T21:21:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c7d48b39_106a2a8f",
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c7d48b39_d05a62fe",
        "filename": "ssl/test/runner/runner.go",
        "patchSetId": 3
      },
      "lineNbr": 2270,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-08-13T22:08:13Z",
      "side": 1,
      "message": "You can remove this actually. If async is true, that flag gets passed in automatically. Ditto below.\n\nThat means this can be merged into the test above, so I would call the test above ClientAuth-RSA-Client and ClientAuth-ECDSA-Client and not bother conditioning them on async.\n\nProbably can likewise drop the \"-AsyncKey\" suffix on the tests below. Instead they\u0027re about testing all the key exchanges because those have different handshake shapes. And one of the things we test about the handshake shapes is that the async private key codepath works.",
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a40a365b_320e8e40",
        "filename": "ssl/test/runner/runner.go",
        "patchSetId": 3
      },
      "lineNbr": 2270,
      "author": {
        "id": 5865
      },
      "writtenOn": "2015-09-02T21:21:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c7d48b39_d05a62fe",
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c7d48b39_9054dacf",
        "filename": "ssl/test/runner/runner.go",
        "patchSetId": 3
      },
      "lineNbr": 2299,
      "author": {
        "id": 5075
      },
      "writtenOn": "2015-08-13T22:08:13Z",
      "side": 1,
      "message": "For consistency, maybe call this ECDHE-ECDSA.",
      "range": {
        "startLine": 2299,
        "startChar": 26,
        "endLine": 2299,
        "endChar": 33
      },
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a40a365b_72081631",
        "filename": "ssl/test/runner/runner.go",
        "patchSetId": 3
      },
      "lineNbr": 2299,
      "author": {
        "id": 5865
      },
      "writtenOn": "2015-09-02T21:21:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c7d48b39_9054dacf",
      "range": {
        "startLine": 2299,
        "startChar": 26,
        "endLine": 2299,
        "endChar": 33
      },
      "revId": "0a0ba015d57675fd8aa3d15b2517064eb360dc8f",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": false
    }
  ]
}