{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "bbc9456c_7688b98a",
        "filename": "ssl/internal.h",
        "patchSetId": 18
      },
      "lineNbr": 2708,
      "author": {
        "id": 5415
      },
      "writtenOn": "2022-09-29T18:54:21Z",
      "side": 1,
      "message": "KeyUpdate\n\nAlthough, looks like this isn\u0027t quite accurate? It\u0027s reset:\n\n- When we receive any application data\n- When we receive a KeyUpdate (request or otherwise), unless it was a \"free\" KeyUpdate that we received via this counter.\n\nIt\u0027s also subtracted from when we consume a KeyUpdate.\n\nThough I\u0027m struggling to come up with a clear description of what that is. It also complicates the meaning of key_update_count. Maybe some variant on key_update_budget?? Not sure what key_update_count should be called at that point.\n\nThoughts?",
      "range": {
        "startLine": 2708,
        "startChar": 57,
        "endLine": 2708,
        "endChar": 75
      },
      "revId": "d99f1e0f4e6840970ea97dcd9df58670d776587e",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d057544_462b9e77",
        "filename": "ssl/internal.h",
        "patchSetId": 18
      },
      "lineNbr": 2708,
      "author": {
        "id": 14196
      },
      "writtenOn": "2022-10-06T21:02:41Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bbc9456c_7688b98a",
      "range": {
        "startLine": 2708,
        "startChar": 57,
        "endLine": 2708,
        "endChar": 75
      },
      "revId": "d99f1e0f4e6840970ea97dcd9df58670d776587e",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8098c020_7cd3b009",
        "filename": "ssl/ssl_lib.cc",
        "patchSetId": 18
      },
      "lineNbr": 1011,
      "author": {
        "id": 5415
      },
      "writtenOn": "2022-09-29T18:54:21Z",
      "side": 1,
      "message": "To make sure I understand: we reset this because, if we receive any data, we assume we\u0027re reading and therefore don\u0027t need to allow for KeyUpdate storms when we\u0027re not reading?\n\nDoes that work? I think there might be some stuff getting out of sync here.\n\nLet\u0027s say we\u0027re an HTTP/1.1 server and the peer (client) implements pipelining. (Or similar protocol.) They send `GET /giant/resource` and then follow that up with `GET /small/resource`. This is small enough that it fits in transport buffers.\n\nWe read `GET /giant/resource` and spew a ton of data at the client. We don\u0027t read the next one because HTTP/1.1 servers typically don\u0027t keep training the read pipe while they\u0027re writing. While we\u0027re spewing data, the client decides to send us a bunch of KeyUpdates.\n\nWe finish spewing data and read `GET /small/resource`. We then write a tiny amount of data, not enough to get this counter up. Then we read again and pick up the KeyUpdates triggered by /giant/resource. But there\u0027s only a `/small/resource`\u0027s worth of budget to cover a `/giant/resource`\u0027s worth of KeyUpdates.\n\n(I\u0027m still kinda dubious whether this kind of peer behavior should be considered \"legitimate\". A client like this likely has a DoS bug itself because a malicious server can just refuse to read, but send enough data to queue up KeyUpdates. At some point, that\u0027ll exceed the transport buffer and just start building up in memory on the client, without bound.)\n\nTo the comment about trying to come up with clear descriptions of these counters, I think if we remove this, our KeyUpdate policy becomes moderately clear:\n\n- You are allowed to give me one 1 KeyUpdate every N records I write\n- You are allowed to accompany every record you write with up to 32 KeyUpdates, outside of the above budget\n\n(I wonder if 32 needs to be quite that high if we\u0027ve also got the write-based budget. I guess there\u0027s also time-based rotations. Though arguably even this CL doesn\u0027t really handle time-based rotations. Suppose it\u0027s an idle HTTP/2 connection but the peer still wakes up every 30 seconds to send a KeyUpdate. 16 minutes later, it\u0027ll break. But idle connections are also expected to close whenever, so that\u0027s not *that* big of a deal.)",
      "revId": "d99f1e0f4e6840970ea97dcd9df58670d776587e",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f47d792_9ed205c8",
        "filename": "ssl/ssl_lib.cc",
        "patchSetId": 18
      },
      "lineNbr": 1011,
      "author": {
        "id": 14196
      },
      "writtenOn": "2022-09-30T15:48:13Z",
      "side": 1,
      "message": "Never resetting it does leave us in the situation where a long lived connection could have a bunch of writes and then be kept spinning, although theoretically not indefinetely.  So one thought here is as you suggest, remove it with the description as you suggest - we could probably also drop it to \"you are allowed to accompany every record you write with a Key Update\" - instead of 32. which sort of make sense and effectively makes it symmetric - then this could simply become \"key_update_budget\" increasing by 1 for every record received from the peer and 1 every 256 records we write to the peer..  I am somewhat concerened about the unbounded growth in this case although again that more or less makes it symmetric.. We could also go as far as making it the same both ways, one for every 256 records read or written... I think that\u0027s still reasonable..",
      "parentUuid": "8098c020_7cd3b009",
      "revId": "d99f1e0f4e6840970ea97dcd9df58670d776587e",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2573ef2_fb65ac5f",
        "filename": "ssl/ssl_lib.cc",
        "patchSetId": 18
      },
      "lineNbr": 1011,
      "author": {
        "id": 5415
      },
      "writtenOn": "2022-09-30T16:28:53Z",
      "side": 1,
      "message": "\u003e Never resetting it does leave us in the situation where a long lived connection could have a bunch of writes and then be kept spinning, although theoretically not indefinetely.\n\nThat\u0027s true, though I think that\u0027s also true without the reset. The peer can just not write anything. Though I suppose it is limited by how much you\u0027re willing to write in response to one \"request\". But, I dunno, suppose, in HTTP/2, I ask for max_streams `GET /giant/resource` in parallel.\n\nSo I figure we have to either decide we\u0027re okay with this, probably by setting 256 to be a large enough number, or not do an approach like this one. My understanding was we\u0027d decided 256 was a large enough number that we wouldn\u0027t *actually* care. (256 full-size records is a budget of one KeyUpdate per 4MiB. A KeyUpdate is, what, 26 bytes? Let\u0027s call it 32. So if we send 1TiB, you\u0027re allowed to turn around and reply with a storm of 8MiB of KeyUpdates. Dunno how terrible we\u0027d consider that to be, though we can tune that by increasing 256 if we don\u0027t like it.)\n\n\u003e we could probably also drop it to \"you are allowed to accompany every record you write with a Key Update\" - instead of 32. which sort of make sense and effectively makes it symmetric - then this could simply become \"key_update_budget\" increasing by 1 for every record received from the peer and 1 every 256 records we write to the peer.. I am somewhat concerened about the unbounded growth in this case although again that more or less makes it symmetric.. We could also go as far as making it the same both ways, one for every 256 records read or written... I think that\u0027s still reasonable..\n\nYeah, I guess the unbounded growth comes from our whether the read rule is cumulative or not. Our current rule is you can accompany a record with 32 KeyUpdates, but, if you decline to, *it won\u0027t build up*. Whereas the write budget is somewhat inherently cumulative because it comes off a different stream.\n\nUnlike the write one, I don\u0027t think we *need* to make the read budget cumulative. But the symmetry is quite attractive since it lets us keep a single `key_update_budget` counter. Dunno. Either sounds promising. I guessing changing the read budget carries a bit of a risk, but sending 32 KeyUpdates with every record is pretty absurd.",
      "parentUuid": "2f47d792_9ed205c8",
      "revId": "d99f1e0f4e6840970ea97dcd9df58670d776587e",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5580cfa1_a5c63497",
        "filename": "ssl/ssl_lib.cc",
        "patchSetId": 18
      },
      "lineNbr": 1011,
      "author": {
        "id": 14196
      },
      "writtenOn": "2022-10-06T21:02:41Z",
      "side": 1,
      "message": "I\u0027ve gone the symmetric route, with a fixed budget starting at 32, which increases for every 256 records processed, and decreases every key update we process.",
      "parentUuid": "e2573ef2_fb65ac5f",
      "revId": "d99f1e0f4e6840970ea97dcd9df58670d776587e",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96d1d78f_9112f35a",
        "filename": "ssl/tls13_both.cc",
        "patchSetId": 18
      },
      "lineNbr": 37,
      "author": {
        "id": 5415
      },
      "writtenOn": "2022-09-29T18:54:21Z",
      "side": 1,
      "message": "Probably need to update this comment now.",
      "revId": "d99f1e0f4e6840970ea97dcd9df58670d776587e",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f0efecfb_ef7d8a09",
        "filename": "ssl/tls13_both.cc",
        "patchSetId": 18
      },
      "lineNbr": 37,
      "author": {
        "id": 14196
      },
      "writtenOn": "2022-10-06T21:02:41Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "96d1d78f_9112f35a",
      "revId": "d99f1e0f4e6840970ea97dcd9df58670d776587e",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212"
    }
  ]
}