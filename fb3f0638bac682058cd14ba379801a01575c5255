{
  "comments": [
    {
      "key": {
        "uuid": "300583d9_e81e5a27",
        "filename": "crypto/fipsmodule/ec/p256-x86_64_tests.txt",
        "patchSetId": 3
      },
      "lineNbr": 1206,
      "author": {
        "id": 5525
      },
      "writtenOn": "2019-01-04T06:54:31Z",
      "side": 0,
      "message": "Above, you say you didn\u0027t know what you were doing to get these coordinates. At least for this case, I can tell you what you did: You calculated the point at infinity by calculating nG or similar.\n\nNotice that (n - 1)G \u003d (2b11cb945c8cf152ffa4c9c2b1c965b019b35d0b7626919ef0ae6cb9d232f8af, 6d333da42e30f7011245b6281015ded14e0f100968e758a1b6c3c083afc14ea0, 3c396f06c1dc69e4f4b2dce51cd660f761064a4ab098ef61ba3868961f0ef178).\n\nWhen you calculate nG \u003d (n - 1)G * G with BoringSSL (at least in the past), you get this representation of the point at infinity:\n\n(2b11cb945c8cf152ffa4c9c2b1c965b019b35d0b7626919ef0ae6cb9d232f8af, 6d333da42e30f7011245b6281015ded14e0f100968e758a1b6c3c083afc14ea0, 0)\n\nNotice that the latter triple is the same as the previous triple except the Z coordinate was set to zero to indicate that it is the point at infinity. Thus, in your old test vector, you weren\u0027t using a true Jacobian representation of the point at infinity but instead were using some implementation\u0027s \"Z \u003d 0 is ∞\" representation.\n\nI know all of this because I did it the same way to generate some similar test vectors. In my case, I believe I used the non-nistz256 BoringSSL implementation.\n\nI don\u0027t know why your other test vectors are the way they are but maybe it is a similar reason.\n\nRegarding the fact that BoringSSL\u0027s representation of points as triples isn\u0027t really the mathematical Jacobian representation: This is because BoringSSL doesn\u0027t treat points purely algebraically; instead it uses Z \u003d 0 as a sentinel. Also, IIRC, it sometimes clears X and Y when Z is zero in order to transparently handle some special cases, maybe ∞ + a \u003d ∞, ∞ + ∞ \u003d ∞, etc. I forget the details of when that matters and when it doesn\u0027t, though. nistz256 also relies on the fact that the affine point (0, 0) isn\u0027t on the curve, which is true for all prime-order curves.",
      "range": {
        "startLine": 1205,
        "startChar": 0,
        "endLine": 1206,
        "endChar": 70
      },
      "revId": "fb3f0638bac682058cd14ba379801a01575c5255",
      "serverId": "66b711a4-aa9b-3dac-9062-916540830212",
      "unresolved": true
    }
  ]
}